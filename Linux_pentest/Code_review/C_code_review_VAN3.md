---
title: C/C++ code review for AVA_VAN.3
updated: 2024-05-31 06:57:46Z
created: 2024-05-31 06:54:18Z
---

# Introduction
This method follows the following steps:
 - List the applicable standards and requirements 
 - perform code review according to the applicable requirements, in the following order:

     . Analysis of the build (the method is currently built around ````gcc````) [mandatory]

     . Analysis using linters (the method currently uses ````splint```` and ````clang-tidy````) [mandatory]

     . Analysis using SAST tools [optional]

     . Manual review [mandatory]

Warning: the evaluator needs to keep in mind that the compiler warning flags pertaining to static analysis, as well as the linter warnings, are not free of false negatives. The sheer number of false negatives may quickly make the analysis unwieldy or impractical. This is the reason why the approach starts with a small number of checks, and only afterwards, moves on to a larger set of checks. If the analysis is impossible due to the number of false negatives, it is still a finding in itself, and should probably be documented somehow in the report...


# List the applicable standards and requirements
List the requirements:
 - Clarify which version of the C standard is meant to be applied.
 - Clarify which coding standard(s) is(are) applicable. If no standard is required, this method backs up to [CERT C](
https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard).
 - check that the evaluation requires AVA_VAN.3 (this method does not cover AVA_VAN.4 or 5).

NB: In the absence of coding standards, additional guidance can also be found in [ANSSI C development rules](https://www.ssi.gouv.fr/en/guide/rules-for-secure-c-language-software-development/).


# Perform the code review (AVA_VAN.3)

[CERT C rules](https://wiki.sei.cmu.edu/) are scaled on 3 levels (L1 being the most critical ones). The following checklist will _ultimately_ detail all rules, but in general, an AVA_VAN.3 evaluation will limit itself to checking the compliance to L1 rules only. These rules are considered a good _rule of thumb_ to check bugs in the TOE code, and therefore is a mandatory step of the method, even if CERT C compliance is not claimed by the developer. 

It means that a non conformity will be blocking _only if it leads to an exploitable vulnerability_. 

On top of CERT C rules, a few transversal topics can be checked _if possible_ and _if relevant_.

## Analysis of the build [mandatory]

### First checks - compliance to CERT C L1 rules

First build the TOE using the compiler options from the following table.

| Rule | gcc option | Comments | Examples |
| :---- | :----:   |          :--- | :--- |
| [EXP33-C. Do not read uninitialized memory](https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory) | ````Wuninitialized```` | Low hanging fruits, e.g. uninitialized locals used in a printf. If the developer does not use this option, or if they "pragmaed" they way out of it, beware! Compilers may optimize out the uninitialized variable access, see e.g. See especially the example of [More Randomness or Less](http://kqueue.org/blog/2012/06/25/more-randomness-or-less/) | [EXP33-C_caught_by_gcc.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\EXP33-C_caught_by_gcc.c)|
| [ARR38-C. Guarantee that library functions do not form invalid pointers](https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers) | ````Wstringop-overread```` | A clean build should take care of the obvious flaws, since the option -Wstringop-overread is enabled by defaut | [ARR38-C_caught_by_gcc.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\ARR38-C_caught_by_gcc.c)|
| [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator) | ````std```` >= c99 | a build by default (without options) will not accept ````gets```` at all (removed since C11). Even -std=c99 will warn that it is deprecated.|[STR31-C_caught_by_gcc.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\STR31-C_caught_by_gcc.c)|
| [STR38-C. Do not confuse narrow and wide character strings and functions](https://wiki.sei.cmu.edu/confluence/display/c/STR38-C.+Do+not+confuse+narrow+and+wide+character+strings+and+functions) | ````-Wincompatible-pointer-types```` | The option warns of some usage of incompatible pointer types when, e.g. use of narrow types on wide functions (wcs.*  , wmem.*, btowc, wctob, .*wc, .*wchar, .*ws, fw.*) or use of wide types (wchar_t, wint_t<br>) on narrow functions (e.g. strncpy). However, it does not explicitly warn the user of all consequences (e.g. wide strings may contain null char, which will result in an undesired truncation). Nevertheless, systematically resolving these warnings solves the issue. Note that the option checks many other incompatibilities that are also potential sources of UB| [STR38-C_caught_by_gcc.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\STR38-C_caught_by_gcc.c) |
|[MEM30-C. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory)| ````Wuse-after-free=2 or 3```` | gcc is able to catch some simple cases of use after free and double free (-Wuse-after-free=2 is included in -Wall). -Wanalyzer-use-after-free can also be used for a clearer output | [MEM30-C_caught_by_gcc.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\MEM30-C_caught_by_gcc.c)  |

### Clean build

When the previous phase is successful, make a clean build, i.e. _at least_ with ````-O1 -Wall -Wextra -Wpedantic -Werror -std=c99/c90```` to catch other potential errors.
Ideally, options -O2/Os and -std=c11 or higher would even be preferred.
For more hints on gcc/clang options, see e.g. [ANSSI C development rules](https://www.ssi.gouv.fr/en/guide/rules-for-secure-c-language-software-development/) §5 and Annex B.2.

Additional tasks:
 - Check implementation-dependant behaviours (if relevant): list various platform-specific behaviours that might have an impact on the analysis: endianness, etc. 
 - Collect the pragmas used by the developer (since they evade the compiler detection), and assess whether the explanations are sufficient.

## Analysis using linters [mandatory]

For most of the rules checked with linters, the tools will not _guarantee_ the absence of a violation, but rather find some simple examples of violations. For this reason, the same rules will often appear in the manual review as well. Both analyzes have to be done! The linter phase merely _simplifies_ the manual review.

### First checks with splint

Perform a first series of CERT C compliance tests with splint, use the following options:

| Rule | splint option | Comments | Examples |
| :---- | :----:   |          :--- | :--- |
| [EXP33-C. Do not read uninitialized memory](https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory) | ````usedef, compdef```` | Variables passed by address to functions: some compilers (incl. gcc) assume that when the address of an uninitialized variable is passed to a function, the variable is initialized within that function. They will *not* report the fact that it was not initialized before being sent to the function.| [EXP33-C_caught_by_splint.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\EXP33-C_caught_by_splint.c) |
| [STR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string](https://wiki.sei.cmu.edu/confluence/display/c/STR32-C.+Do+not+pass+a+non-null-terminated+character+sequence+to+a+library+function+that+expects+a+string) |  ````+stringliteralnoroom````   | will catch simple cases of literal, non null terminated, strings. NB: is this splint check does not run, try at least to check option bugprone-not-null-terminated-result in clang-tidy|[STR32-C_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\STR32-C_caught_by_tools.c)|
|[MEM30-C. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory)| ````usereleased````| splint finds additional cases, such as the reuse of memory previously released in realloc (when using realloc, the original pointer is freed and must not be used anymore! you must use the result of realloc instead): NB: if this check does not run, check clang-tidy option unix.Malloc |[MEM30-C_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\MEM30-C_caught_by_tools.c)|
|[FIO30-C. Exclude user input from format strings](https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings) | ````formatconst```` | detects non constant format strings - but splint is prone to parse errors in complex codes so you may revert to clang-tidy | [FIO30-C_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\FIO30-C_caught_by_tools.c)|
|[ERR33-C. Detect and handle standard library errors](https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors) and [POS54-C. Detect and handle POSIX library errors](https://wiki.sei.cmu.edu/confluence/display/c/POS54-C.+Detect+and+handle+POSIX+library+errors)| ````retvalother```` | this option is even present in -weak mode and warns about all unused return values (not only stdlib or POSIX functions). However, the return value can be read without really/fully be taken into account, so a manual review is still needed |[ERR33-C_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\ERR33-C_caught_by_tools.c)|

When splint runs without warning, make a full run of splint without options.   

### clang-tidy - compliance to CERT C L1 rules
When the splint checks are successful, run a full set of clang-tidy checks: ````clang-tidy -checks=-*,clang-analyzer-*,-clang-analyzer-cplusplus* <file.c> --````, and pay extra attention to violations to the following rules:

| Rule | clang-tidy check | Comments | Examples |
| :---- | :----:   |          :--- | :--- |
| [EXP34-C. Do not dereference null pointers](https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers) | ````core.NullDereference```` | Will get the low hanging fruits (calls to ````->```` without NULL check) | [EXP34-C_caught_by_clang.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\EXP34-C_caught_by_clang.c)|
| [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator) | ````security.insecureAPI. DeprecatedOrUnsafeBufferHandling```` | Warns on "occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset"|[STR31-C_caught_by_tools.c]|
| [MEM34-C. Only free memory allocated dynamically](https://wiki.sei.cmu.edu/confluence/display/c/MEM34-C.+Only+free+memory+allocated+dynamically) | ````unix.Malloc```` | gcc detects simple cases (such as reallocation of arrays) and less simple ones. However, the -fanalyzer option can be slow and clang-tidy (with the check ) provides more readable and direct diagnostics in the less simple cases, so it may be worth running directly| [MEM34-C_caught_by_gcc.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\MEM34-C_caught_by_gcc.c)  |
|[FIO30-C. Exclude user input from format strings](https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings) | ````N/A```` | the diagnostic "format-security" is enabled by default and detects non constant format strings | [FIO30-C_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\FIO30-C_caught_by_tools.c)|

When clang-tidy runs without warning, make a full run of clang-tidy with all options.   

## Analysis using SAST tools [optional]

For the moment, the method does not include verification according to SAST tools. However, should the developer use such tools, the evaluator is encouraged to leverage this work in order to reduce the effort of the manual review: many SEI CERT C rules are implemented by various tools.

## Manual review [mandatory]

Since linters and SAST tools do not completely cover the level 1 CERT C rules, a manual review is still needed. On top of this verification, some additional checks may be needed on various topics (concurrency, design errors, etc.)

### Compliance to CERT C L1 rules [Mandatory]

| Rule | Topic | Method | Examples |
| :---- | :----:   |          :--- | :--- |
| [EXP33-C. Do not read uninitialized memory](https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory) | Expressions | Additional review for bugs not caught by gcc/splint/clang-tidy: check initializations that use aligned_alloc(), calloc(), malloc(), realloc(), because these functions do *not* initialize the contents of the allocated memory! It is especially a risk when using realloc on larger sizes than the initial malloc. | [EXP33-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\EXP33-C_not_caught_by_tools.c) |
|[EXP34-C. Do not dereference null pointers](https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers) | Expressions | Additional review of cases not caught by clang-tidy: <br> - List all use (including wrappers) of aligned_alloc(), calloc(), malloc(), realloc(); <br> - verify the null checks of allocated var before use | [EXP34-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\EXP33-C_not_caught_by_tools.c) |
|  [ARR38-C. Guarantee that library functions do not form invalid pointers](https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers)| Arrays  | Check all uses of relevant functions (see Hint). For calls that take a pointer and an integer size, the given size should not be greater than the element count of the pointer. For calls that take a pointer and two integers, one integer represents the number of bytes required for an individual object, and a second integer represents the number of elements in the array. The resulting product of the two integers should not be greater than the element count of the pointer were it expressed as an unsigned char *.  <br>Tips: some functions work in multiples of char and others in multiples of some other type. Don't mix! Typically any use of sizeof in a context of wide char is a codesmell.<br>Hint: relevant functions:<br> - fgets, fgetws, mbstowcs, wcstombs, mbrtoc16 	mbrtoc32, mbsrtowcs, wcsrtombs, mbtowc, mbrtowc, mblen, mbrlen, memchr, wmemchr, memset, wmemset, strftime, wcsftime, strxfrm, wcsxfrm, strncat, wcsncat, snprintf, vsnprintf, swprintf, vswprintf, setvbuf, tmpnam_s, snprintf_s, sprintf_s, vsnprintf_s, vsprintf_s, gets_s, getenv_s, wctomb_s, mbstowcs_s, wcstombs_s, memcpy_s, memmove_s, strncpy_s, strncat_s, strtok_s, strerror_s, strnlen_s, asctime_s, ctime_s, snwprintf_s, swprintf_s, vsnwprintf_s, vswprintf_s, wcsncpy_s, wmemcpy_s, wmemmove_s, wcsncat_s, wcstok_s, wcsnlen_s, wcrtomb_s, mbsrtowcs_s, wcsrtombs_s, memset_s <br> - bsearch, bsearch_s, qsort, qsort_s, fread, fwrite| [ARR38-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\ARR38-C_not_caught_by_tools.c)|
| [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator) | Characters and strings | Search [bad usage of fgets, getline, getchar, getenv, etc.](https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator)<br>Beware that strncmp still truncates! "Ensure that strings are null terminated before passing into strcmp. This can be enforced by always placing a \0 in the last allocated byte of the buffer."<br>Beware that although strlcpy null terminates, we still have a truncation issue. Check that the length is checked! <br>Beware that some functions do not have secure variants in C11/Annex K, and may lead to similar errors: strlcat, itoa, strtok... [TODO:clarify/complete the list]<br>Eventually, pay attention to iterations on strings represented by simple char arrays, since an off-by-one would not necessarily be caught by a tools either. |[STR31-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\STR31-C_not_caught_by_tools.c) |
|[STR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string](https://wiki.sei.cmu.edu/confluence/display/c/STR32-C.+Do+not+pass+a+non-null-terminated+character+sequence+to+a+library+function+that+expects+a+string)  | Characters and strings | Search for ````realloc```` of strings: if the string is shortened, the null terminator is cut, and has to be reintroduced after the truncation<br>Beware that although clang-tidy warns that strncpy is unsafe, it is only because of the lack of length checks. It does not warn the user that the function does not null terminates, and therefore outputs potentially dangerous strings. Be sure to null terminate!  |[STR32-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\STR32-C_not_caught_by_tools.c) |
|[MEM30-C. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory)| Memory management | TBD: cases that may or may not be detected by tools<br>     . depending on the version of C used, many things can go wrong if the new size passed to realloc is zero<br>     . Check wrappers of aligned_alloc(), calloc(), malloc(), realloc(); they may have specific behaviours (return values, etc.) that make usage more error-prone| |
|[FIO34-C. Distinguish between characters read from a file and EOF or WEOF](https://wiki.sei.cmu.edu/confluence/display/c/FIO34-C.+Distinguish+between+characters+read+from+a+file+and+EOF+or+WEOF)| I/O | On rare cases where the int and char are the same size, some bugs can happen (confusing EOF with a valid character). A quick check consists in verifying the size of int on the TOE (see Hint after the table). Then check for each instance of getchar that the code uses an int and not a char (same goes for getwc that returns a wint_t, not a wchar_t)! Otherwise it will be possible for a valid character value to compare equal to the value of EOF (when EOF is negative, which sould be the case, and if compared to a char, it will be converted -> trouble ensues)<br>Most non custom charsets are safe but beware is a custom charset is used. See https://www.greenend.org.uk/rjk/tech/cfu.html for details. In any case, a check with ````feof(stdin)```` and ````ferror(stdin)```` are preferred to a ````c != EOF```` |[FIO34-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\FIO34-C_not_caught_by_tools.c) |
|[FIO37-C. Do not assume that fgets() or fgetws() returns a nonempty string when successful](https://wiki.sei.cmu.edu/confluence/display/c/FIO37-C.+Do+not+assume+that+fgets%28%29+or+fgetws%28%29+returns+a+nonempty+string+when+successful)| I/O |  if fgets() or fgetws() are used, even if result is not NULL, the buffer may have only been fed a \0. So typically do not assume ````strlen(buf) - 1```` is positive |[FIO37-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\FIO37-C_not_caught_by_tools.c)|
|[ENV32-C. All exit handlers must return normally](https://wiki.sei.cmu.edu/confluence/display/c/ENV32-C.+All+exit+handlers+must+return+normally)| Environment |  Search all functions registered by exit cleanup functions (search ````at_quick_exit```` and (````atexit````). All these function should simply ````return````. beware if they call ````exit()```` or ````longjump()````.|[ENV32-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\ENV32-C_not_caught_by_tools.c)|
|[ENV33-C. Do not call system()](https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177)| Environment | Search for ````system(```` : possible command injection in the string passed to the call. The ````exec```` family of functions should be used instead.|[ENV33-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\ENV33-C_not_caught_by_tools.c)|
|[SIG30-C. Call only asynchronous-safe functions within signal handlers](https://wiki.sei.cmu.edu/confluence/display/c/SIG30-C.+Call+only+asynchronous-safe+functions+within+signal+handlers)| Signals | First identify signal handlers (search ````signal(````). If the functions calls anything other than abort(), _Exit(), quick_exit(), or signal(), look if the called function is asynchronous-safe (See Hint). Same goes if the handler changes a variable that is not ````volatile sig_atomic_t````. After having identified the handlers and reducing the target to a small set of files, it is possible to use gcc -fanalyzer with option -Wanalyzer-unsafe-call-within-signal-handler - however, it does not catch all violations (e.g. it catches free but not puts or raise, and does not warn if there is a call to longjmp that results in calling asynchronous unsafe functions).<br>Hint: [the SEI CERT page](https://wiki.sei.cmu.edu/confluence/display/c/SIG30-C.+Call+only+asynchronous-safe+functions+within+signal+handlers) lists all asynchronous safe funcitons that cam be used in a signal handler. <br>TODO: there are other signal handling mechanisms other than the plain old signal API. Might be worth including a reference to those as well the following manpages are a good start on a technical/api level on unix and more specifically, linux: signal(7), sigaction(2), signalfd(2) |[SIG30-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\SIG30-C_not_caught_by_tools.c)|
|[ERR33-C. Detect and handle standard library errors](https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors)| Error handling | See full list of stdlib fucntions on the [CERT page](https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors). If not all of them can be analyzed, focus on functions that are more likely to be made to fail by the attacker (focus on interfaces, and memory allocation functions)  |[ERR33-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\ERR33-C_not_caught_by_tools.c)|
|[POS30-C. Use the readlink() function properly](https://wiki.sei.cmu.edu/confluence/display/c/POS30-C.+Use+the+readlink%28%29+function+properly)| POSIX| always read ````sizeof(buf)-1```` when using readlink (e.g. ````readlink("/usr/bin/perl", buf, sizeof(buf)-1);````)|[POS30-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\POS30-C_not_caught_by_tools.c)|
| [POS35-C. Avoid race conditions while checking for the existence of a symbolic link](https://wiki.sei.cmu.edu/confluence/display/c/POS35-C.+Avoid+race+conditions+while+checking+for+the+existence+of+a+symbolic+link)|POSIX| classical TOCTOU : search for keywords ````lstat````, ````S_ISLNK````, ````open````. Models of compliant solutions are provided in the link.|[POS35-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\POS35-C_not_caught_by_tools.c)|
|[POS36-C. Observe correct revocation order while relinquishing privileges](https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges) and [POS37-C. Ensure that privilege relinquishment is successful](https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful)|POSIX|Search ````setuid````, ````seteuid````, ````setgid````, ````setfsuid```` and ````setfsgid```` to check that privileges are dropped correctly (e.g. wrong sequence that make setgid fail). might require tests!<br>Also search ````setgroups(```` to check if supplementary group IDs are used.<br>Check the link above for the analysis, since it is not trivial.|[POS36-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\POS36-C_not_caught_by_tools.c) and [POS37-C_not_caught_by_tools.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Code_review\_resources\POS37-C_not_caught_by_tools.c)|
|[POS39-C. Use the correct byte ordering when transferring data between systems](https://wiki.sei.cmu.edu/confluence/display/c/POS39-C.+Use+the+correct+byte+ordering+when+transferring+data+between+systems)|POSIX| unlikely to happen due to the probable impact. This verification can be skipped if difficult to check, expecially in cases where there aren't many interactions with 3rd party systems|N/A|
|[POS47-C. Do not use threads that can be canceled asynchronously](https://wiki.sei.cmu.edu/confluence/display/c/POS47-C.+Do+not+use+threads+that+can+be+canceled+asynchronously)|POSIX|search ````thread_cancel```` for possible occurrence. Check link for details|N/A|
|[POS54-C. Detect and handle POSIX library errors](https://wiki.sei.cmu.edu/confluence/display/c/POS54-C.+Detect+and+handle+POSIX+library+errors)|POSIX| alway check results of fmemopen, open_memstream, posix_memalign.|N/A|
|[MSC32-C. Properly seed pseudorandom number generators](https://wiki.sei.cmu.edu/confluence/display/c/MSC32-C.+Properly+seed+pseudorandom+number+generators)|Misc.| More generally, check crpto against BSI applicable rules|N/A|
|[MSC33-C. Do not pass invalid data to the asctime() function](https://wiki.sei.cmu.edu/confluence/display/c/MSC33-C.+Do+not+pass+invalid+data+to+the+asctime%28%29+function)|Misc|Search for uses of ````asctime(```` and ````asctime_r(````. asctime_s() or strftime() should be used instead.|N/A|
|[MSC41-C. Never hard code sensitive information](https://wiki.sei.cmu.edu/confluence/display/c/MSC41-C.+Never+hard+code+sensitive+information)|Misc| Use the ````strings```` utility to check the strings used in the program and search for possible sensitive hardcoded data |N/A|



### Other possible checks for AVA_VAN.3 [optional]
These checks may be performed whenever relevant, depending on the context, product type, etc. It is ultimately an evaluator's choice to chose any of them

#### Concurrency
[TODO] this section attemps at providing a practical method to search races, but realistically, it is still a bit abstract to help in practise beyond a rough understanding of the dangers. then again, that topic is way too extensive to cover. 

If multithreading is strongly present in the TOE, the evaluator should ask themselves if API races are present (See CppCon 2018: Geoffrey Romer “What do you mean "thread-safe"?”) : 
````
A given line of code is guaranteed to have no API races if it calls no thread-hostile functions, all inputs are live [not destroyed], and each input is
 - not being accessed by other threads, or
 - thread-safe, or
 - thread-compatible and not being mutated by any thread.
````
note about liveness : you have to manage the concurrency of destruction vs access separately

So : 

Does the code implement sensitive operations? If so, they must be implemented in an atomic fashion. Does the changed code use shared resources? If so, they must be protected against starvation or access conflicts.  

Does the code include objects/data possibly accessed from different threads?
 - If so, are these data/objects thread-safe? (built-in data or std:mutex are typically thread-safe, also std::atomic<T>)
     - typically : completely stateless and reentrant (no use of global variables, parameters passed by value, no use of class attributes, rely only on input parameters passed by value and local variables, no call to stateful function, return only copies of data) -> then no problem
 - If not, are they at least thread compatible *and not mutated by one of the threads?* (i.e. safe in concurrency *as long as they are not mutated*).
     - Beware 1! It is not limited to explicit writes : a read() method, even marked as const, may change a mutable in the object. Beware notably when std::function is used as it is not thread compatible.
     - Beware 2! a read() method, even marked as const, may change shared data that does not belong to the object (e.g. a static var, pointer to shared data) 
         - standard C/C++ functions marked as "thread safe" do not do that; 
         - a developer's function should NOT do that, and this should be marked as a bug (this is a thread-hostile behaviour and there is generally a way to rework the function so that it is not)
 - if not, check the correct use of typically CriticalSection, std::mutex, std::unique_lock, to handle these objects
    NB : beware when seeing the *volatile* keyword as it is not meant for interthread communication. 



#### Input validation 
Check TSFIs for possible malicious inputs to the TOE.

##### Code injection/Remote or Arbitrary Code  Execution
[TODO] Code injection vectors depend on a lot of factors (mostly the mechanisms in the implementation behind an interface accepting inputs to be interpreted as some form of code). as such, it's better to trace out how code injection usually works in different contexts to inform that section a bit better.

A few words on shell injections: as a general warning, beware of blacklists (of course, we would want to forbid ` or | that are typically dangerous as inputs on posix, but more generally, it's way better to simply use a very limited _allow list_ of alphanumerical characters + ".", "_", "-")

##### Indirect object reference: directory traversal, auth bypass, redirect...
This is a typical web use case but in theory applicable to C/C++ programs as well. The gist of it is that user inputs are strings. 
The question is: 
 - does the TOE use these strings as strings, OR
 - does the TOE inpterpret these strings in order to interpret them as indexes in a safe set of values?

In a few words, does the TOE use indirect object references to avoid arbitrary/malicious inputs? 

Examples:
 - Directory Traversal: Can the user select files to be handled? Does the code handles a (raw) string description of the file from the user, or does it translate it as an index in a structured list/array/map of available files ? In the first case the user may trick the TOE by asking "../../filename", etc.
 - Auth bypass, redirect: same thing: can you pass an email or an URL as input, or does the TOE force you to give an ID, that it will use as an index in a set of safe emails or URLs? 

#### Output sanitizing    
TBD

##### Reflected injection attacks
TBD 

##### External Entities
TBD

##### Insecure Deserialization 
TBD

#### Other issues 
TODO: adaptation of TR03161-2
1 The application MUST validate all inputs before processing them to filter out potentially
malicious values before processing.
2 The application MUST mask incoming and outgoing data, or sanitize potentially malicious
characters, or refuse to process them.
3 Error messages and log files MUST NOT contain sensitive data (e.g. user identifiers or session
IDs).
4 Potential exceptions in the program flow (exceptions) MUST be intercepted, handled
in a controlled manner and documented. Technical error descriptions (e.g. stack traces)
MUST NOT be displayed to the user.
5 In case of exceptions in the program flow, the web application SHOULD abort access to
sensitive data and securely delete it from memory.
6 All options supporting development (e.g. developer URLs, test methods,
remnants of debugging mechanisms, etc.) MUST be completely removed in the production
version.
7 Modern security mechanisms such as obfuscation and bundlers SHOULD be used
8 Static code analysis tools SHOULD be used to develop the application.
9 If the web application uses URL redirects, this MUST be done in a controlled manner.
10 The web application MUST provide measures to prevent functionalities that are not within
the manufacturer's development authority from being introduced into the web
application and executed.
11 before the application is deployed in production.
Sensitive data MUST NOT appear in the URL. The web application MUST handle such data
in HTTP request headers or POST parameters.
O.
Also : 
-	Identification/Authn: 
o	Login identification interface does not allow user guessing or enumeration (also timing attacks on login for higher level evaluations?)
o	make a clear inventory of preauth actions and ensure that you cannot elevate privileges from there 
-	Authz/ Access control: input parameters do not command privileges given to users: the users provide only credentials and the TOE decides what they can access
if users want to access an object, they provide an indirect object reference on which the TOE will apply access control. Not a direct reference (-> path traversal, bruteforcing, request forgery, many things)
-	Sessions: public session parameters (session ID, variables, etc) should not allow impersonation, they should be refreshed in a way that avoids guessing, fixation, etc etc (a good requirement can’t really be improvised on the spot but you get the idea)
-	There is also something to be said about security domains within the TOE but it’s hard to define a general statement (how does a VPN implementation separate black/red traffic on the TOE? How does a network device separate the traffic from two virtual networks in memory? how does the TOE separate the access to sensitive data from various users (e.g. it can leverage the OS protections by managing each TOE user as an OS user, with corresponding permissions etc)
-	No test users, credentials, etc present in code



##### hardening of control flow (if,  switch...) 
TBD    

##### Improper Authentication (Design)
TBD    

##### Math Errors : overflow, wraparound, division by 0...
TBD    

##### Inappropriate Use of Default Values (Design) : default per-missions, etc. 
TBD

##### Use of unsafe legacy functions
TBD


# Annex - Hints

Check int size from the shell (important for EOF issues):
````
binary=$(mktemp)
cat <<\EOF | cc -o $binary -x c -
#include <stdio.h>
int main() {
    printf("int=%lu bytes\n", sizeof(int));
    printf("long=%lu bytes\n", sizeof(long));
}
EOF
$binary
rm $binary
````

