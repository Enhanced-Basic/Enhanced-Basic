#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
/*
 This C code snippet exhibits errors that are found by either splint or clang-tidy 

  └─$ splint STR32C-C_caught_by_tools.c  
  Splint 3.1.2 --- 21 Feb 2021

  STR32C-C_caught_by_tools.c: (in function func)
  STR32C-C_caught_by_tools.c:17:19: String literal with 4 characters is assigned
      to char [3] (no room for null terminator): "abc"
    A string literal is assigned to a char array that is not big enough to hold
    the null terminator. (Use -stringliteralnoroom to inhibit warning)

  Finished checking --- 1 code warning
*/

/*
Example (printf)
This code example is noncompliant because the character sequence c_str will not be null-terminated when passed as an argument to printf(). (See STR11-C. Do not specify the bound of a character array initialized with a string literal on how to properly initialize character arrays.)
*/
  
void func(void) {
  char c_str[3] = "abc";
  printf("%s\n", c_str);
}

/*
 Example (strncpy())
Although the strncpy() function takes a string as input, it does not guarantee that the resulting value is still null-terminated. In the following noncompliant code example, if no null character is contained in the first n characters of the source array, the result will not be null-terminated. Passing a non-null-terminated character sequence to strlen() is undefined behavior.
*/
  
enum { STR_SIZE = 32 };
  
size_t funcstrncpy(const char *source) {
  char c_str[STR_SIZE];
  size_t ret = 0;
 
  if (source) {
    c_str[sizeof(c_str) - 1] = '\0';
    strncpy(c_str, source, sizeof(c_str));
    ret = strlen(c_str);
  } else {
    /* Handle null pointer */
  }
  return ret;
}


/* main */
int main(int argc, char *argv[]) {
    int i;
    printf("%d\n",argc);
    for(i=0;i<argc-1;i++)
    {
        printf("%s",argv[i]);
    }    
    return 0;    
}
