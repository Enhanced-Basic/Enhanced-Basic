
#include <locale.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/* Example (calloc())
In this noncompliant code example, temp_num, tmp2, and num_of_records are derived from a tainted source. Consequently, an attacker can easily cause calloc() to fail by providing a large value for num_of_records. 
When calloc() fails, it returns a null pointer that is assigned to start. If start is null, an attacker can provide a value for temp_num that, when scaled by sizeof(signal_info), references a writable address to which control is eventually transferred. The contents of the string referenced by tmp2 can then be used to overwrite the address, resulting in an arbitrary code execution vulnerability.
*/
enum { SIG_DESC_SIZE = 32 };
 
typedef struct {
  char sig_desc[SIG_DESC_SIZE];
} signal_info;
  
void func(size_t num_of_records, size_t temp_num,
          const char *tmp2, size_t tmp2_size_bytes) {
  signal_info *start = (signal_info *)calloc(num_of_records,
                                          sizeof(signal_info));
 
  if (tmp2 == NULL) {
    /* Handle error */
    return;
  } else if (temp_num > num_of_records || temp_num == 0) {
    /* Handle error */
    return;
  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {
    /* Handle error */
    return;
  }
 
  signal_info *point = start + temp_num - 1;
  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);
  point->sig_desc[SIG_DESC_SIZE - 1] = '\0';
  /* ... */
  free(start);
}




/* main */
int main(int argc, char *argv[]) {
    int i;
    printf("%d\n",argc);
    for(i=0;i<argc-1;i++)
    {
        printf("%s",argv[i]);
    }    
    return 0;    
}
