
# General strategy
Let us now assume you have (or have already obtained) obtained a reverse shell and a TTY. Many possible exploitation paths are possible, but we will structure them as follows:
 - Low-hanging fruits (obvious config errors)
 - exploitation of available resources
 - exploitation of scripts and command calls
 - exploitation of dynamic dependencies
 - process injection
 - (other)

# Low-hanging fruits
Run the [Low hanging fruits script](_0_System_AVA_testing\_resources\Low_hanging_fruits.sh): ````sudo ./Low_hanging_fruits.sh > results.md````

Then follow the indications in the resulting Markdown file to check if there are hints of vulnerabilities. 

# Exploitation of available resources
## Identification
### Files  (Non-upstream)
Check files permissions (not writable by an attacker), e.g. .service, .timer or .socket units - can you overwrite the files constituting a TOE component?
### Sockets, D-Bus...  (Non-upstream)
 - can you communicate with sockets / d-bus used by the TOE?
### File system and drives 
Check unwanted privileges:
 - do you have unexpected permissions on the filesystem or access to credentials?
### Users, groups 
Check unwanted privileges
 - Can you natively escalate privileges thanks to a group you belong to?
 - What is the password policy?

## Exploitation 
[TODO] To be detailed to clarify the actual attack commands for
 - files
 - sockets, dbus
 - FS and drives
 - users/groups

# Exploitation of scripts and command calls
## Identification
### Files  (Non-upstream)
In binaries: 
 - In a whitebox context, perform a code review to search keywords ````system````, ````popen````, ````execvp````, ````execlp````.
 - In a blackbox context, search the symbols directly in the binary: ````nm -D <path to binary> | grep <dangerous call: system, popen, execvp, execlp...> ````. 
 NB:  nm works in very simple cases (non stripped binary, etc). Extend this part for more complex cases.
Additionally:
 - Check for the presence of shells scripts in the TOE directories: ````find . -type f -perm /111 -exec file '{}' ';' | awk -F: '/script/ { print $1 }'```` 
 NB: the script cannot be run on / due to the likely high number of hits you would get.
 [TODO] to be completed with other scripts types (perl, etc.)
 - Check cron jobs:
     - Is the PATH being modified by some cron and you can write in it?
     - Any wildcard in a cron job?
     - Some modifiable script is being executed or is inside modifiable folder?
     - Have you detected that some script could be or are being executed very frequently? (every 1, 2 or 5 minutes)

## _Privileged_ scripts and _dangerous_ command calls
The following calls are dangerous because they result in a shell invocation and can be influenced (e.g. by the $PATH variable): ````system````, ````popen````, ````execvp````, ````execlp````.
Additionally, should they call shell scripts, these scripts may have elevated privileges and could be leveraged by an attacker.

### Exploit the shell scripts themselves

If you identified scripts, check first [Exploiting shell scripts for privilege escalation](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Shell.md)

### Exploit calls to shell or commands
 - Search a writable folder ````find / -type d -perm -o+w 2>/dev/null````   
 - Check if you can change $PATH, so that it points to the writable folder before any other.
 - In the writable folder create a link to a GTFObin to replace the command called by your privileged binary. 

Alternatives: instead of linking to an existing binary, you can 
 - copy the existing binary, 
 - create an arbitrary shell script and give it the binary name 
 - etc (don't forget to give it execution rights!)

### Pratical examples 

Both following Rootme challenges rely on calls to ````system````
- [ch11 - Bash - System 1](../../../../Pentesting/Challenges%20and%20CTFs/Rootme/App-script/ch11%20-%20Bash%20-%20System%201.md)
- [ch12 - Bash - System 2](../../../../Pentesting/Challenges%20and%20CTFs/Rootme/App-script/ch12%20-%20Bash%20-%20System%202.md)


## _Safe_ command calls

If the binary calls a script by a method that does not perform path name substitution (i.e. ````execl````, ````execle````, ````execv````, or ````execve````, see [CERT](https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177) for more details), *or if previous methods failed*, you still have possible attack vectors in the scripts themselves: see [Exploiting shell scripts for privilege escalation](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Shell.md).

# Exploitation of dynamic dependencies
In case the privileged binary is dynamically linked, try to influence its execution by changing the LD_LIBRARY_PATH or LD_PRELOAD variables.

NB: normally, this method does not work on *SUID* binaries.

## Identification
Warning: the exploitation is quite simple but it has a lot of prerequisites: it requires you either to compile on the TOE (compiler needed) or to cross-compile. Additionally, you need to be able to execute your binary on the TOE. Therefore, better to check early that all prerequisites are met:
 - Check if utilities/compilers are present ````which nmap aws nc ncat netcat nc.traditional wget curl ping gcc g++ make gdb base64 socat python perl php ruby xterm doas sudo fetch docker lxc ctr runc rkt kubectl````
 - check if the binary has dynamic dependencies: ````ldd <path to binary>```` (or look for the ````NEEDED```` entries in the output of ````readelf --dynamic````)
 - Can you change LD_LIBRARY_PATH? Can you change LD_PRELOAD?
 - Are there folders where you can write *and* execute? especially if they are inside the PATH? 
     - ````find / -type d -perm -o+w 2>/dev/null````
     - ````findmnt -l | grep noexec```` (if everything is noexec you can try to remount without it ````mount -o remount,rw,exec <path, e.g. /usr>````)
 - Do you have either a compiler on the TOE *or* a way to push a binary from outside the TOE? ````which nmap aws nc ncat netcat nc.traditional wget curl ping gcc g++ make gdb base64 socat python perl php ruby xterm doas sudo fetch docker lxc ctr runc rkt kubectl````
   - NB: if you do not have a compiler on the TOE but a way to push file son it, the safest option is to seacrh a full toolchain that will allow you to compile statically on the TOE. 
     - Many toolchains are available on https://musl.cc/
     - don't forget to compile with gcc -static -staticlibgcc!


### Required privileges (Non-upstream)
Check each component actual privileges and units
### Services, processes...  (Non-upstream)
Any unknown software running? Any software running with more privileges than expected?
## Exploitation 
Generate an .so that will perform the action you want to perform with elevated rights.

As a general rule you would typically launch a shell but if the target has limited privileges, you may have to limit the action so that it actually works! 
E.g. if the target has only DAC-bypassing elevated capabilities you could use it to access restricted files, etc. 


## Practical examples
See (simple) examples in
 - [preload.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\_resources\preload.c) for an attack on LD_PRELOAD 
 - [libcap.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\_resources\libcap.c) for an attack on LD_LIBRARY_PATH

# Process injection
## Identification
Check that 
 - ````sys/kernel/yama/ptrace_scope```` is set to 1 or lower. If not, these techniques will not be applicable
     - if 0, possibility to attach to any process
     - if 1, only to a child process
     - from 2, admin only
 - ````dd```` is available

### Required privileges (Non-upstream)
Check each component actual privileges and units
### Services, processes...  (Non-upstream)
Any unknown software running? Any software running with more privileges than expected?


 

## Injection with ````ptrace```` or ````/proc/PID/mem```` 

### Exploitation
Several approaches are possible, in order of increasing complexity:
 - if ptrace_scope=0, 
     - peek in the memory of a privileged process to obtain cleartext keys, passwords... (e.g. in sshd)
     - tamper with a privileged process to make it execute a command with elevated privileges (e.g. a shell)
 - if ptrace_scope=1: tamper with a userland process in order to obtain unprivileged but _arbitrary_ code execution.


#### Peeking into memory
Check that you can actually read the targeted ````/proc/<pid>/mem````. In most implementations, even with ptrace_scope=0 and a theoretically world-readable file, some additional protections will prevent you to access the file (e.g. capabilities).
This is a good first check before trying to tamper with a process using ptrace. 

#### Tampering with a specific privileged process
THis scenario makes sense either when trying to inject code in a privileged process (to execute it with elevated privileges) or in a same-level privilege process (to access assets that are not readable outside this process memory)

The first example is trivial (I'm a user and I want to execute code as root or a more privileged user). An example of the second case is when we have root _but are not able to read cleartext credentials that are exchanged in an SSH session because everything is done in memory_. 

A generic tool is available on [gaffe23 github](https://github.com/gaffe23/linux-inject). 

Its compatibility is limited (to their own admission it has only been successfully tested on Arch/Ubuntu, and does not work out-of-the-box on Debian. I _sort of_ adapted it to kali with mixed results).

As a general rule, attaching to a process does not work on SUID processes from kernel 2.4.x, due to the use of the dumpable flag. However, but it is worth trying:
 - if the system uses a non standard linux, it may have been forked on a kernel < 2.4 or modified on this aspect for debugging purpose
 - the program itself may explicitly authorize by setting the flag back to value 1 (search `prctl(PR_SET_DUMPABLE, 1)`).
 -
 - It has still to be tried in a real life evaluation, but the score may well be within an AVA_VAN.3 if not too many adaptations are needed.

#### Practical examples
See [Adaptation of linux-inject to kali](_resources\custom-linux-inject-master)

The adaptation is not trivial: this version required a couple of days to adapt to kali and a recent glibc (change the code so that it searches `dlopen` instead of `__libc_dlopen_mode` and `libc` instead of `libc-`, fix a non null filled array for /proc/<pid>/maps filenames in utils.c) but does not work reliably. Typically:
 - it works successfully on the sample target, or on a bash running an infinite loop
 - it does NOT work on a ping (SEGFAULT)

Some additional adaptations may be required in the assembly or other parts (it might be a similar problem than e.g. https://0x00sec.org/t/linux-infecting-running-processes/1097 in section "those two bytes"). 

In its current state it can be worth looking at [keylogging scenarios](https://github.com/raj3shp/termspy)

Additional resources for a deeper look at this topic:
 - [Alternative implementation](https://github.com/raj3shp/ptrace_code_injection) (not tested)
 - [Process injection on sshd](https://blog.xpnsec.com/linux-process-injection-aka-injecting-into-sshd-for-fun/) (this is the example where root tries to read SSH credentials on the fly) (not tested)
 - an [alternative implementation in python](https://ancat.github.io/python/2019/01/01/python-ptrace.html) (not tested)

#### Generic execution of arbitrary code
If ptrace_scope is 1, or if we just want to execute unprivileged arbitrary code, another method is available: see [Unprivileged Process Injection Techniques in Linux](https://joev.dev/posts/unprivileged-process-injection-techniques-in-linux): _On Linux you use the ptrace syscall to remotely control the execution of a process and read/write into its memory._ [...] _the procfs mount implements mem device files for all processes in the namespace, available at /proc/[pid]/mem. These devices allow using standard filesystem syscalls to manipulate remote process memory. Behind the scenes, they are more or less a clone of parts of the existing ptrace syscalls; and in fact use the same ptrace_scope sysctl and resulting permissions. This allows us to use standard (util-linux and coreutils) commands (like dd or printf) to seek through and overwrite remote process memory via these device files; which lets us stage native code quietly and without needing a writable location on disk or relying on esoteric binaries._

A good starting point for in-memory injection can be found on [sektor7 blog](https://blog.sektor7.net/#!res/2018/pure-in-memory-linux.md)
We will favor this approach in pentest because:
 - it will score lower in attack potential (window of opportunity is larger because it does not leave artifacts and does not require to upload anything)
 - it will also work on TOEs with noexec filesystems

The method describes following several In-Memory-Only methods: Tmpfs, GDB, Python, Self-modifying dd. [Unprivileged Process Injection Techniques in Linux](https://joev.dev/posts/unprivileged-process-injection-techniques-in-linux) quotes other, newer methods, and a simpler "dumb" implementation. The evaluator should favor this latter implementation as a first attempt and move on to other methods if needed. This approach has the benefit of relying only on ````dd```` which is part of ````coreutils````.  

The main steps are:
 - From a shell, open a write fd to /proc/self/mem
 - Read /proc/self/syscall to find the return address of the read() syscall
 - In a child subshell, skip the fd to this address using dd skip=..., then write the shellcode payload
 - The parent process will then read() from the child process, triggering the payload

But they will not work by default and I did not try to adapt them yet, so the attack scoring is unknown.

Additional resources 
 - [here](https://cyber.aon.com/aon_cyber_labs/linux-based-inter-process-code-injection-without-ptrace2/) and 
 - [there](https://github.com/arget13/DDexec)

 
# VM/Sandbox escape
[TODO]
 - VM
 - docker: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security
 - etc.

# Other
If these methods fails, 
[search for SW bugs in the program](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Software_vulnerability_research.md).
