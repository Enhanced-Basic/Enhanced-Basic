---
description: Privilege escalation from anonymous network access
---
# Privilege escalation from anonymous network access - table of contents
 - [General strategy](#general-strategy)
 - [Network services protocols](#network-services-protocols)
 - [Network services design](#network-services-design)
 - [Network services configuration and implementation](#network-services-configuration-and-implementation)
 - [Network services CVEs](#network-services-CVEs)
 - [Appendix - about exploitation of vulnerabilities](#appendix---about-exploitation-of-vulnerabilities)




# General strategy
From an anonymous access, the evaluator may try to elevate privileges in two main ways:
 - Baby steps: *Bypass identification/authentication* to get a user session - this is a matter of design and/or implementation, and will vastly benefit from the knowledge of ADV_TDS
 - Shortcut: *Trigger a SW bug* on the TOE that will execute arbitrary code or a system command (with the privileges of the compromised network services, either non privileged or privileged). This is a pure implementation problem.
 
Devising a strategy for constraint time evaluation is not trivial, even if there are general rules of thumb:
 - the *Bypass identification/authentication* approach is generally a good candidate for starting tests, because functional tests are supposedly already present in the documentation
 - the *Trigger a SW bug* approach is not a good candidate if the network services are mostly upstream, up-to-date open source components (bugs may be present but not likely to be found in such a constrained timeframe). Quite the opposite, it may be a good candidate if the developer created a full TCP/IP stack from scratch.

From the [Prerequisites](Linux_pentest/0_Prerequisites.md), the evaluator gets a first basic analysis strategy: for each *network service* available, the evaluator already decided whether they should review/test its
 - protocols, 
 - design, 
 - configuration and implementation, 
 - CVEs. 

# Network services protocols

The first step is for the evaluator to clarify, for a given network services, whether and how basic security properties are defined:
 - *identification/authentication* (mutual or not, multi factor or not, which types of credentials...)
 - *secure channel: integrity/confidentiality/replay protection* 
 - *authorization*
 - *session management* (tokens, cookies...)

In many cases, the service will a standard protocol for most of these properties and complete the rest by proprietary means or by using linux utilities. 

(simple) EXAMPLE: in the TOE XXX, a sshd service is be used to authenticate as an application XXX or as user, either root, privileged (wheel group) or unprivileged.
 - For users
   - identification/authentication will use: ID:login + passwd
     - SSH protocol for interactive login 
     - PAM to validate the user
   - secure channel: SSH (ciphersuites YYY)
   - authorization: PAM, using linux ACLs (authorization is based on UID and GID)
   - session management: PAM 
 - For the application XXX
   - identification/authentication will use: SSH
   - secure channel: SSH (ciphersuites YYY)
   - authorization: SSH (definition of authorized keys)
   - session management: none

(less simple) EXAMPLE: in the TOE XXX, a YYY service is accessed by an API. Users are supposed to login first with a password, then issue service tickets that can be used either for user sessions or application connections.
 - For users (first login)
   - identification/authentication will use: ID:login + passwd
     - HTTP basic auth protocol 
     - PAM to validate the user
   - secure channel: TLS (ciphersuites YYY)
   - authorization: proprietary: user can only issue service tickets
   - session management: no session
 - For users (using service tickets)
   - identification/authentication will use: ID:service ticket
     - HTTP basic auth protocol, using the service tickets as both user and passwd 
   - secure channel: TLS (ciphersuites YYY)
   - authorization: proprietary: access to only three API calls (SetStatus, GetStatus, CloseSession) is allowed, and only if the ticket is valid
   - session management: proprietary: session is based on the service ticket, and is valid until CloseSession is called 
 - For the application XXX: etc.

The evaluator will first try to challenge these main principles:
 - are there several protocols used by a service?
 - what can go wrong, especially when different protocols are used to enforce different properties?
   - auth is not tied to ID: can user A authenticate by submitting user B's valid token?
   - authorization is not tied to ID/auth: can user A still have authorization when their credentials expire or are invalidated?
   - session is not tied to ID/authn/authz: can user A use session identifiers from user B? If so, will it have user A or user B authorizations? If the admin user and unprivileged users are supposed to use separate network/ports, are they even allowed to login on the other port?
   - secure channel is not tied to ID/auth: can I mount a channel without having user credentials? what are the allowed preauth interactions? can several users share the same secure channel parameters, and there fore spy on each others credentials?  
   - secure channel is not tied to session/authorization: is the session still running when closing the channel? Can I still the session by stealing the channel? etc.
 - are there properties that are not enforced (e.g. anti replay)? Does the rest of the TOE provide a protection?


# Network services design

## Standard protocols
When a standard protocol is used to enforce a given property, be sure that its security recommendations have been followed. 

EXAMPLE: if sessions are managed by TLS 1.2, check whether the TOE supports session resumption and whether it implements the recommendations from RF5246 F.1.4.  Resuming Sessions

## Lesser known and proprietary protocols
When a non standard protocol is used to enforce a security property, a detailed analysis should be performed. 

If such a protocol is used to implement authentication or a secure channel, it should be considered a warning for the evaluator (and possibly the certification scheme), since such an analysis is likely to require more workload than allowed by the evaluation. In any case, the recommended best practices would be the following:
 - identification and authentication: [OWASP authentication cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
 - secure channel: [Building	Secure	Channels, Kenny	Paterson, Information	Security Group][https://summerschool-croatia.cs.ru.nl/2014/slides/Building%20Secure%20Channels.pdf]

Quite the contrary, custom mechanisms are frequent for session management or authorization, and they can often be reviewed within the limits of the evaluation. for each mechanism, the evaluator should evaluate te design against a state-of-the-art or set of best practices. The recommended best practices would be the following:
 - authorization and access control: [OWASP authorization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html) 
 - session management: [OWASP session management cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)

[TODO] the following links are not yet included in the method but provided as a set of additional hints:
 - https://owasp.org/www-chapter-london/assets/slides/ - OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson.pdf


# Network services configuration and implementation

## Standard protocols - config only 

When a standard protocol provides a given security property (e.g. integrity /confidentiality), you still need to check whether it is correctly implemented - this will be a question of conformance to its definition (standard, RFC...) - e.g. TLS with [Achelos Test inspector](https://www.achelos.de/de/services-loesungen/testsuiten/tls-inspector/).

This check will most of the time be split between a configuration check and an implementation check. As mentioned in the [Prerequisites](Linux_pentest/0_Prerequisites.md), the implementation will be checked only for non-upstream modules, whereas for upstream implementations, only the config will be checked (see e.g. [SSH](Linux_pentest/Applications/SSH.md))


## Implementation

This part will focus on checking the implementation of proprietary or lesser-known protocols for 
 - *identification/authentication*
 - *secure channel: integrity/confidentiality/replay protection* 
 - *authorization*
 - *session management* 

[TODO]: For the moment, the reader may find this section severely lacking - it will be filled in progressively with general hints on functional code review. 

### General checks
[TODO]: to be completed 

Check the *underlying network stack* for potential parsing / memory usage errors (think fuzzing)

### Identification/authentication
[TODO]: to be completed 

Check the identification/authentication forms themselves:
 - if implemented by web apps, they may be subject to XSS, SSRFs, etc. 
 - in any case, the timing for auth may provide an oracle to the attacker

At the underlying layers, what can be done, e.g.: for a TOE with HTTPS, is it possible to communicate in HTTP before TLS is up? 

## Secure channel
[TODO]: to be completed 

Check the firewalling functionality : can the secure channel fail, and what happens if it does? E.g. for a TOE with IPSec, upon error, does the firewall block all traffic, rebuild the tunnel, let traffic pass in cleartext? (See bad strongswan FW rules - auto=start vs auto=route, issues with start_action=none, etc.)

## Authorization
[TODO]: to be completed 

Does the stack share resources of different users in the same process, the same database?


## Session management
[TODO]: to be completed 

# Network services CVEs 
Perform a [Public vulnerability analysis](../Pentesting/Pentesting%20methods%20and%20tools/Public%20vulnerability%20analysis/Public%20vulnerability%20analysis%20101.md) on the selected modules.

# Appendix - about exploitation of vulnerabilities
On the principle, exploitation consists in
 - performing a MiTM or sniff the network
 - intercept/capture packets 
 - read, replay or transform the packets (and in that case send the transformed packets to the other party)

Some variations are possible, such as exploiting a session that was not clearly terminated to impersonate a party, etc.

This section does not detail the method, as it will not be required in CC evaluations as a general rule. It provides pointers to useful tools, in case the evaluator wants to expliore further the topic, or if a customer needs a proof of concept at some point.

### Capture
The evaluator should theoretically be able to carry out a complete Man-in-the-middle/spoofing attack.

In addition to packet manipulation tools, particularly they he wishes to take advantage of an open sample, the evaluator can also proceed by hooking the TOE or third-party systems interacting with the TOE (for example existing test tools), or even modify the source code of such software in order to generate malicious frames.

[TODO]: how to trigger all actions on the TOE that that will actually create interesting traffic 
[TODO]: how to denoise captures before analysis 

#### Capture on the network
[TODO] Build a setup for MitM using ARP Poisoning - see [examples](https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network) using bettercap and arpspoof, or using ICMP redirect.

[TODO]: build a setup for capture using promiscuous port settings 
[TODO]: help on capture tools : wireshark/tshark, tcpdump, scapy

#### Capture on the TOE
[TODO]: build a setup 
[TODO]: help on capture tools : eBPF...

#### Capture on a third-party system (e.g. modify test tools)
[TODO]: build a setup 
[TODO]: additional guidance, see [Packet modification or crafting](#packet-modification-or-crafting)

### Analysis
[TODO]: how to analyse packet origin (traceback)
[TODO]: how to analyse packet content (help on packet analyzers such as Wireshark, snort, tcpdump/windump, fiddler, suricata, netsniff-ng, but also dissection with scapy)
[TODO]: guidance on capture formats (pcap, other?).

### Packet modification or crafting
[TODO]: how to handle packets using nc, pwntools, scapy, fragroute, etc. 





