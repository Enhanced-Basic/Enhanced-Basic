---
description: Privilege escalation from anonymous network access
---

# General strategy
From an anonymous access, the evaluator may try to elevate privileges in two main ways:
 - Baby steps: *Bypass identification/authentication* to get a user session - this is a matter of design and/or implementation, and will vastly benefit from the knowledge of ADV_TDS
 - Shortcut: *Trigger a SW bug* on the TOE that will execute arbitrary code or a system command (with the privileges of the compromised network services, either non privileged or privileged). This is a pure implementation problem.
 
Devising a strategy for constraint time evaluation is not trivial, even if there are general rules of thumb:
 - the *Bypass identification/authentication* approach is generally a good candidate for starting tests, because functional tests are supposedly already present in the documentation
 - the *Trigger a SW bug* approach is not a good candidate if the network services are mostly upstream, up-to-date open source components (bugs may be present but not likely to be found in such a constrained timeframe). Quite the opposite, it may be a good candidate if the developer created a full TCP/IP stack from scratch.

From the [Prerequisites](Linux_pentest/0_Prerequisites.md), the evaluator gets a first basic analysis strategy: for each *network service* available, the evaluator already decided whether they should review/test its protocol, design, configuration, code, and/or CVEs. 

# Protocol

The first step is for the evaluator to clarify, for a given network services, whether and how basic security properties are defined:
 - *identification/authentication* (mutual or not, multi factor or not, which types of credentials...)
 - *secure channel: integrity/confidentiality/replay protection* 
 - *authorization*
 - *session management* (tokens, cookies...)

In many cases, the service will a standard protocol for most of these properties and complete the rest by proprietary means or by using linux utilities. 

(simple) EXAMPLE: in the TOE XXX, a sshd service is be used to authenticate as an application XXX or as user, either root, privileged (wheel group) or unprivileged.
 - For users
   - identification/authentication will use: ID:login + passwd
     - SSH protocol for interactive login 
     - PAM to validate the user
   - secure channel: SSH (ciphersuites YYY)
   - authorization: PAM, using linux ACLs (authorization is based on UID and GID)
   - session management: PAM 
 - For the application XXX
   - identification/authentication will use: SSH
   - secure channel: SSH (ciphersuites YYY)
   - authorization: SSH (definition of authorized keys)
   - session management: none

(less simple) EXAMPLE: in the TOE XXX, a YYY service is accessed by an API. Users are supposed to login first with a password, then issue service tickets that can be used either for user sessions or application connections.
 - For users (first login)
   - identification/authentication will use: ID:login + passwd
     - HTTP basic auth protocol 
     - PAM to validate the user
   - secure channel: TLS (ciphersuites YYY)
   - authorization: proprietary: user can only issue service tickets
   - session management: no session
 - For users (using service tickets)
   - identification/authentication will use: ID:service ticket
     - HTTP basic auth protocol, using the service tickets as both user and passwd 
   - secure channel: TLS (ciphersuites YYY)
   - authorization: proprietary: access to only three API calls (SetStatus, GetStatus, CloseSession) is allowed, and only if the ticket is valid
   - session management: proprietary: session is based on the service ticket, and is valid until CloseSession is called 
 - For the application XXX: etc.

The evaluator will first try to challenge these main principles:
 - are there several protocols used by a service?
 - what can go wrong, especially when different protocols are used to enforce different properties?
   - auth is not tied to ID: can user A authenticate by submitting user B's valid token?
   - authorization is not tied to ID/auth: can user A still have authorization when their credentials expire or are invalidated?
   - session is not tied to ID/authn/authz: can user A use session identifiers from user B? If so, will it have user A or user B authorizations? If the admin user and unprivileged users are supposed to use separate network/ports, are they even allowed to login on the other port?
   - secure channel is not tied to ID/auth: can I mount a channel without having user credentials? what are the allowed preauth interactions? can several users share the same secure channel parameters, and there fore spy on each others credentials?  
   - secure channel is not tied to session/authorization: is the session still running when closing the channel? Can I still the session by stealing the channel? etc.
 - are there properties that are not enforced (e.g. anti replay)? Does the rest of the TOE provide a protection?


# Design

## Standard protocols
When a standard protocol is used to enforce a given property, be sure that its security recommendations have been followed. 

EXAMPLE: if sessions are managed by TLS 1.2, check whether the TOE supports session resumption and whether it implements the recommendations from RF5246 F.1.4.  Resuming Sessions

## Lesser known and proprietary protocols
When a non standard protocol is used to enforce a security property, a detailed analysis should be performed. 

If such a protocol is used to implement authentication or a secure channel, it should be considered a warning for the evaluator (and possibly the certification scheme), since such an analysis is likely to require more workload than allowed by the evaluation. In any case, the recommended best practices would be the following:
 - identification and authentication: [OWASP authentication cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
 - secure channel: [Building	Secure	Channels, Kenny	Paterson, Information	Security Group][https://summerschool-croatia.cs.ru.nl/2014/slides/Building%20Secure%20Channels.pdf]

Quite the contrary, custom mechanisms are frequent for session management or authorization, and they can often be reviewed within the limits of the evaluation. for each mechanism, the evaluator should evaluate te design against a state-of-the-art or set of best practices. The recommended best practices would be the following:
 - authorization and access control: [OWASP authorization cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html) 
 - session management: [OWASP session management cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)

[TODO] incorporate additional hints:
 - https://owasp.org/www-chapter-london/assets/slides/ - OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson.pdf


# Configuration and implementation
## Standard protocols 
When a standard protocol provides a given security property (e.g. integrity /confidentiality), you still need to check whether it is correctly implemented - this will be a question of conformance to its definition (standard, RFC...). This can be checked:
 - either at the network level, when a complete test suite is available:
   - e.g. TLS with Achelos / tlssled
 - or manually at the applicative level.

This check will most of the time be split between a configuration check and an implementation check. As mentioned in the [Prerequisites](Linux_pentest/0_Prerequisites.md), the implementation will be checked only for non-upstream modules, whereas for upstream implementations, only the config will be checked (see e.g. [SSH](Linux_pentest/Applications/SSH.md))

Is the implementation robust, both for the part that implements the session *and for the underlying network stack*? (think fuzzing)

# Code 
## ID/Auth
identification/authentication forms subject to XSS, SSRFs, etc. more generally [Bugs](#bugs) on a preauth interface

 - at the underlying layers, what can be done: is it possible to communicate in HTTP before TLS is up? 
e.g. VPN. upon error, the tunnel may be closed. The configuration of the VPN will define whether new cleartext will be blocked, or passed in new tunnel or passed in cleartext -> possible leak
See bad strongswan FW rules (auto=start vs auto=route, issues with start_action=none, etc.)
## Access control
General hints:
 - does the stack share resources of different users in the same process, the same database?

# CVEs 
Perform a [Public vulnerability analysis](../Pentesting/Pentesting%20methods%20and%20tools/Public%20vulnerability%20analysis/Public%20vulnerability%20analysis%20101.md) on the selected modules.

# Appendix: about exploitation of vulnerabilities
On the principle, it consists in
 - perform a MiTM or sniff the network
 - intercept/capture packets 
 - read, replay or transform the packets (and in that case send the transformed packets to the other party)

Some variations are possible, such as exploiting a session that was not clearly terminated to impersonate a party, etc.

### Capture
[TBD] Tips to:
- how to be sure to trigger all actions on the TOE that that will actually create interesting traffic 
- how to denoise captures before analysis 
#### On the network
- setup
- capture : wireshark/tshark, tcpdump, scapy
#### On the TOE
- setup
- eBPF...

### Analysis
How to analyze captured packets:
- origin (traceback) and;
- content (understanding packet analyzers such as Wireshark, snort, tcpdump/windump, fiddler, suricata, netsniff-ng, but also dissection with scapy), and;
- understanding of capture formats (pcap, other?).
### Packet modification or crafting
nc, pwntools...
How to handle packets (scapy, fragroute, etc.). 
The evaluator must ultimately be able to carry out a complete Man-in-the-middle/spoofing attack.
In addition to packet manipulation tools, particularly if he wishes to take advantage of an open sample, the evaluator can also proceed by hooking the TOE or software interacting with the TOE (for example existing test tool), or even modify the source code of such software in order to generate malicious frames.




