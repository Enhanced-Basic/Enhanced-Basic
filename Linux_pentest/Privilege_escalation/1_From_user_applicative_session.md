# General strategy

# Inventory
The inventory of applicative access 

# Applications with a predefined method
 - [Restricted shells](_0_Linux_pentest\3_Annex_Applications\Restricted_Shell.md) 
 - [Busybox](_0_Linux_pentest\3_Annex_Applications\Busybox.md)

# Configuration and implementation 
Check the config files!
Detailed examples for
 - [SSH](_0_Linux_pentest\3_Annex_Applications\SSH.md)
 - ...
## PAM
When an application uses PAM to authenticate/authorize users, check the following (lifted from the [linux-PAM application development guide](https://www.chiark.greenend.org.uk/doc/libpam-doc/html/adg-security.html)):
 - does the application correctly use the return value from pam_authenticate? (PAM only provides a value, it's the application role to *actually* restrict access based on this value)
 - Can the user influence the name of the PAM service used to authenticate them? (in which case *they* can decide the authorization scheme will be used). Trivial example, does the application just uses the name of the executable launched by the user? (the attacker can then trick the app just by ln the target to another name, that reflects an existing but poorly protected service)
 - if the app uses getpwnam or syslog, be careful that any pointers you get from these calls may be corrupted by PAM calls. So either you call these functions after your PAM calls, or you copy their pointer outputs in a custom place, so that it cannot be accessed by standard libc call.
 - check carefully the pam conversation function (pam_conv) 
 - check the separation between
     - the requesting user (in a local context, it would be the UID of the running process. In a remote context, it could be a UID submitted in an API call - more generally, the app generally redefines it security model independently of the processes IDs). the application should ideally use PAM_RUSER to store this value, and ideally the PAM_RHOST as well (NULL = unknown; localhost = invoked directly from the local system; or `other.place.xyz`)
     - the identity of the user who grants the service (in a local or remote context, it would be the EUID of the running process). 
     - the new (assumed) identity of the user once the service is granted. The application should normally store this in PAM_USER
 - The application should not accept prompts of arbitrary length without checking for resource allocation failure - and fail gracefully

# Design issues



# Other applications #
[TODO]
