---
title: Pentesting an SSH server
---

# Protocol and design
The SSH protocol is a well-studied and well-recognized protocol. For this reason, the evaluator is not supposed to analyze or otherwise challenge its presence in a product or its design. The evaluator will instead focus on the compliance to the [set of well recognized RFCs](https://www.openssh.com/specs.html) that define this protocol.

# Implementation
There are several existing implementations of SSH, it is advised to consider [the most common ones](https://en.wikipedia.org/wiki/Comparison_of_SSH_servers) as upstream version, and to not challenge their implementation. More obscure or proprietary implementations should be considered non-upstream and be reviewed. This should be a warning for the evalautor and certifier, since checking the compliance to the SSH RFCs is possibly very time-consuming.

# Configuration
## Quick checks
From a root access on the TOE, retrieve the contents of
 - /etc/ssh/sshd_config and,
 - if it exists, /etc/ssh/authorized_keys 
 - If a SSH client is used on the TOE, 
     - users configuration files (~/.ssh/config)
     - the system-wide configuration file (/etc/ssh/ssh_config)

Note when testing in pure blackbox: *Banner:* You can grab the banner via (nc -vn <ip> 22) but it's much simpler to just type a few basic nmap commands:
```
nmap -p22 <ip> -sC # Send default nmap scripts for SSH, will give you a fingerprint of the host keys
nmap -p22 <ip> -sV # will try to retrieve the version of the SSH but more importantly gives you the supported version of the protocol WHICH SHOULD BE 2!
nmap -p22 <ip> --script ssh2-enum-algos # Lists the supported algorithms, see crypto 
ssh-keyscan -p 22 <ip> # Retrieve host public keys 
nmap -p22 <ip> --script ssh-hostkey --script-args ssh_hostkey=full # alternative to retrieve host public keys but keyscan is more likely to work
nmap -p22 <ip> --script ssh-auth-methods --script-args="ssh.user=root" # Lists authentication methods
```
## Elevate privileges
In sshd_config:
 - check if the TOE uses [Allow|Deny][Users|Group] consistently with user and group TOE access control policy
 - check if ChrootDirectory is used
 - Compression should be set to delayed or no to avoid preauth attacks
 - HostbasedAuthentication must be set to no
 - KerberosAuthentication should be set to no 
 - MaxAuthTries must be set to limit the brute force attempts
 - PasswordAuthentication should be set to no (otherwise each security incident on the server risks leaking the user keys, which will then have to be changed)
 - PermitEmptyPasswords should be set to no
 - PermitOpen should not be used
 - PermitRootLogin should be set to no  -> goto Fuzzing
 - PermitUserEnvironment should be set to no
 - Protocol must be 2
 - StrictModes should be set to yes
 - UsePAM should be set to yes. Meaning that sshd has to run as root, also check that UsePrivilegeSeparation is set to yes
 - if SFTP is active, and for users accessing SFTP, the ForceCommand parameter should be set to internal-sftp, in order to avoid [SFTP command execution](https://book.hacktricks.xyz/network-services-pentesting/pentesting-ssh)

In authorized_keys:
 - Check if the TOE uses the capacity to limit some users to some commands, and with which options

Check that AGD forces admin to change default host keys / user passwords (if not and if PoC is needed, goto CTF section)

## Bypass flow control
Based on the list of available ciphers in sshd_config and/or users ssh/config files: check conformity to BSI [TR-02102-4] (NB: rather than use [SSH audit](https://github.com/jtesta/ssh-audit) and blindly trust the tool recommendations)

Check that AGD warns users against server key changes, that could be due to a MitM (if not and if PoC is needed, goto CTF)

## Tamper/craft TOE outputs
### Pivoting
In sshd_config:
 - AllowTCPForwarding should be set to no, but as users have shell access, this should be eplored further, rather than be a blocking point 
 - PermitTunnel should be set to no
 - X11Forwarding should be set to no

In users ssh/config files:
 - X11Forwarding should be set to no

For more details, see 
 - https://book.hacktricks.xyz/generic-methodologies-and-resources/tunneling-and-port-forwarding
 - https://github.com/MegaManSec/SSH-Snake

### Control characters and log injection
try to inject control characters in login names, cipher, or any other text possibly written in logs

### Annex: Fuzzing
By default, fuzzing should be selected only on proprietary/unusual implementations. If the TOE uses a patched OpenSSH, it is not likely that we will find anything in a constraint-time fuzzing campaign.

If fuzzing has to be performed, here are a few hints that can be explored

Two preexisting tools that may not be very interesting:
 - an existing Perl script: https://packetstormsecurity.com/files/download/71252/sshfuzz.txt
 - additional fuzzing on version strings (same): https://www.rapid7.com/db/modules/auxiliary/fuzzers/ssh/ssh_version_2

For a serious attempt to fuzz e.g. with AFL, see https://www.vegardno.net/2017/03/fuzzing-openssh-daemon-using-afl.html 


# Annex: PoC 
This section actually makes sense ony in a blackbox setting, when the TOE does not allow to regenerate host keys... or in CTF

## Weak/already compromised keys 

*Quick test:* If short RSA host keys are used, Get the public SSH key of server, then convert it to x509
```
ssh-keyscan -t rsa <IP> -p <PORT> > sshpub.pub # if you haven't the key already
ssh-keygen -f  sshpub.pub -e -m pem  
```
decode the ASN.1 with http://ldh.org/asn1.html or openssl asn1decode (supposedly this works but not on my computer : sed "/--/d" sshpub.pem | openssl asn1parse | grep "INTEGER" | sed "s/.*://")
Eventually check the modulus in http://www.factordb.com/ (after a hex to decimal conversion)

NB: beware that keyscan may give you a public key that is present but not used! so better to check with nmap, which will tell you if the key is actually used.

*Known bad keys:*
use Metasploit scanner/ssh/ssh_identify_pubkeys or nmap (see https://nmap.org/nsedoc/scripts/ssh-publickey-acceptance.html) to check whether a known bad key has been used (https://github.com/rapid7/ssh-badkeys/tree/master/authorized)

NB: very specific case of CVE-2008-0166: If the SSH is age 2006-2008, or if the key is likely to have been generated at this time, you can exploit : https://github.com/g0tmi1k/debian-ssh 

## User enumeration and password brute force
Enumeration is (theoretically) possible with metasploit, using the technique described in https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/auxiliary/scanner/ssh/ssh_enumusers.md
(I could not make it work in a test setting, though, soI do not develop the brute force part of it, it might need tinkering anyway)

*Known default passwords* : check https://book.hacktricks.xyz/network-services-pentesting/pentesting-ssh#default-credentials
(only relevant for CTFs!)

## MitM
Nothing to do by default but check https://github.com/jtesta/ssh-mitm if the customer needs an exploit
