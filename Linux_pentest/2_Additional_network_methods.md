---
description: Additional network methods  
---

# Table of contents
* [Bypass flow control (network evasion)](#bypass-flow-control---network-evasion)
    * [Switches - routers](#switches---routers)
        * [Switch spoofing](#switch-spoofing)
        * [Double tagging](#double-tagging)
        * [IPv6 specifics](#ipv6-specifics)
        * [Switches and routers - going further](#switches-and-routers---going-further)
        * [Switches and routers - tools and exploitation](#switches-and-routers---tools-and-exploitation)
    * [Firewalls - IDS - IPS](#firewalls---ids---ips)
        * [Packet content manipulation](#packet-content-manipulation)
        * [Fragmentation and overlapping](#fragmentation-and-overlapping)
        * [IDS and IPS - Going further](#ids-and-ips---going-further)
        * [IDS and IPS - Tools and exploitation](#ids-and-ips---tools-and-exploitation)
    * Reverse proxies [planned but not started]
    * VPNs and secure channels [planned but not started]
    * Diodes and TAPs [planned but not started]
* Tamper/craft TOE outputs - pivoting or output poisoning [planned but not started]


# Bypass flow control - network evasion
The typical example of flow control as a primary security function is a firewall function or VPN. The actual flow control functionality will depend on the TOE. In this example, _bypassing control flow_ means _evading the FW rules_, _making cleartext flow to/from the VPN_ or simply _circumventing the confidentiality/integrity protection of the VPN_. Similar types of attacks can concern:
* Network switches: bypassing the VLAN segregation
* Diodes: bypassing the unidirectionnality, or the content inspection...
* etc.

## Switches - routers
This section will describe attacks related to TOEs that act as switches (level 2, based on MAC), routers (level 3, based on IP addresses) or both. The main functionalities targeted here are:
 - the correctness of the transfer/routing
 - the segregation of the network in several VLAN (or similar)

### Switch spoofing
Evasion can be performed by using the Dynamic Trunking Protocol (DTP). In doing so, the attacker imitates a trunking switch and can communicate with the target switch without the VLAN limitations. [Here is a proposed implementation](https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network#id-802.1q-vlan-dtp-attacks) using yersinia. Another tool, frogger, tries to provide integrated VLAN hopping by implementing the trunk attack, as well as additional discovery tasks (identification of VLANs, connections by creating a virtual interface, ARP scan).

### Double tagging
Double tagging consists in encapsulating the target VLAN tag in a packets tagged with the legitimate tag. The switch will read and validate the legitimate tagm then strip it before retransmitting, creating a valid transmission to the target. Hacktricks also provides a simple implementation of double tagging using scapy (1 is the attacker and 20 the target):
```` 
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```` 

A similar attack, described in [Hacktricks](https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network#layer-3-private-vlan-bypass), consists in crafting a packet for the IP address of the target but with the MAC address of the router.

### IPv6 specifics
 - Check if Split DNS is used, and try to recover AAA records from a target 
 - Check if the TOE prevents targets to send router advertisement messages (see rfc6105) / deploy a rogue DHCP server (see rfc7610)
 - see possibility of undesired transition between methods (6to4 [2], ISATAP [3], Teredo [4], etc.) 

Rationale:
 - DNS
     - NSA guidance : The Domain Name System (DNS) has been expanded for IPv6 with a new AAAA record that provides IPv6 addresses in addition to the A record that provides IPv4 addresses. 
     - Therefore, a dual stack DNS implementation may need to support both A and AAAA records. Due to SLAAC and other mechanisms, sensitive information could be included in the AAAA records for internal hosts. Split DNS uses two separate DNS servers created for the same domain, one for the external network and one for the internal network. The goal of split DNS, as opposed to a single DNS, is to increase security and privacy by not inadvertently exposing sensitive information in a DNS record from the internal network to the external network. NSA recommends implementing split DNS, for both IPv4 and IPv6 networks
 - local link
	 - NSA guidance : IPv6 defines network functions that operate on the local link. This includes link-layer address resolution, router discovery, and stateless auto-configuration of addresses. Compared to IPv4, local-link operations for IPv6 are more complex and provide more attack surface. Therefore, any relevant mitigations (i.e., Router Advertisement (RA) Guard to protect against rogue RA messages, Dynamic Host Configuration Protocol for IPv6 (DHCPv6) Shield to protect against rogue DHCPv6 servers) provided by switches and routers should be considered.

### Switches and routers - going further
Previous attacks are pretty run-of-the mill and may not be sufficient to claim VAN.3 resistance of a switch/router. Additional tests may include attacks on:
 - VTP (VLAN Trunking Protocol)
 - STP (spanning tree protocol)
 - specific vendor protocols such as CISCO Discovery Protocol (CDP) 
 - MAC Flooding (supposedly fixed in modern switches)
 - etc.

Note: in IPv4, we do not check MitM using e.g. ARP poisoning or ICMP redirect, unless the ST claims that the TOE provides explicit protection against it (e.g. Cisco Dynamic ARP Inspection or usage of static ARP tables). Same logic applies to the equivalent protocols in IPv6 (e.g. NDP/ND).

Such attacks frequently cross the line between DoS and evasion, especially when the targeted device suddenly starts acting transparently upon failure. For this reason it is not trivial to distinguish between relevant and non relevant attacks. Therefore, it is recommended that the evaluator first checks the claimed features of the TOE before building a test plan.

### Switches and routers - tools and exploitation
Tools:
 - [scapy](https://scapy.net/)
 - [yersinia](https://www.kali.org/tools/yersinia/), 
 - [frogger](https://github.com/nccgroup/vlan-hopping---frogger)

[TODO:] add practical examples


## Firewalls - IDS - IPS 
The principle of evasion/insertion attacks is in most cases to leverage the difference in packet filtering/recomposition between the IDS/FW and the target. This section gathers some relatively basic attacks of this type. 

More complex attacks are hard to assess them at the level of a CC evaluation: they should _not_ be explored, unless the TOE includes _both the IDS and the target_, and/or _explicitly claims resistance to these attacks_: in this case, clarify the IDS and target behaviours as part of ADV in order to inform the tests.


### Packet content manipulation
Several approaches courtesy Hacktricks ([TODO]: complete and detail):
 - TTL manipulation: `Send some packets with a TTL enough to arrive to the IDS/IPS but not enough to arrive to the final system. And then, send another packets with the same sequences as the other ones so the IPS/IDS will think that they are repetitions and won't check them, but indeed they are carrying the malicious content.` (Nmap option: --ttlvalue <value>)
 - Signature bypass: `Just add garbage data to the packets so the IPS/IDS signature is avoided.` (Nmap option: --data-length 25)
 - Invalid checksum: `Sensors usually don't calculate checksum for performance reasons. So an attacker can send a packet that will be interpreted by the sensor but rejected by the final host. Example: Send a packet with the flag RST and a invalid checksum, so then, the IPS/IDS may thing that this packet is going to close the connection, but the final host will discard the packet as the checksum is invalid.`
 - Uncommon IP and TCP options: `A sensor might disregard packets with certain flags and options set within IP and TCP headers, whereas the destination host accepts the packet upon receipt.`

### Fragmentation and overlapping

Tests:
 - **Simple fragmentation attacks**
     - **IPv4:** check that the TOE drops packets with Fragment Offset = 1 (see [RFC1858](https://datatracker.ietf.org/doc/html/rfc1858))
     - **IPv6:** 
         - test: check _any_ overlapping fragment is dropped (see [RFC5722](https://datatracker.ietf.org/doc/html/rfc5722))
         - review: check that initial fragments without flags or port numbers are _treated with suspicion_ (see [IPv6 Security: Attacks and Countermeasures in a Nutshell, Ullrich et al](https://www.usenix.org/system/files/conference/woot14/woot14-ullrich.pdf))
         - review: check that atomic fragments are processed independently from normal fragments (see [RFC6946](https://www.rfc-editor.org/rfc/rfc6946))

Hacktricks states `Just fragment the packets and send them. If the IDS/IPS doesn't have the ability to reassemble them, they will arrive to the final host.`. We take a more structured approach:
 - **On IPv4**, the evaluator may typically want to bypass packet filters that apply rules on the first fragment only:
     - tiny (TCP) fragments, so that TCP flags are on the next fragments (and consequently ignored)
     - overlapping fragments, so that the first fragment contains innocuous header information, that will be rewritten by the next fragments.
 - **On IPv6**, attacks may be more ambitious, since the overlapping may be used to overwrite more information (such as source or destination ports). See [Attacking IPv6 Implementation Using Fragmentation, Antonios Atlasis](https://media.blackhat.com/bh-eu-12/Atlasis/bh-eu-12-Atlasis-Attacking_IPv6-WP.pdf) for more details.

### IDS and IPS - going further
[TODO] add external resources on FW evasion and discuss - testing FW evasion is tricky, since it is dependent on context, rules expressiveness and usability, etc. For the moment, this aspect is not addressed in this method and is considered more a functional test of the FW capacity than a security topic. The same rules holds for gateway that allow or block traffic based on protocol analyses.

### IDS and IPS - tools and exploitation
Tools:
 - [scapy](https://scapy.net/)
 - [Pwntools](https://docs.pwntools.com/en/stable/)
 - [Sniffjoke](https://github.com/vecna/sniffjoke)

[TODO:] add a PoC with ScaPy/pwntools using e.g. [this writeup](https://www.supernetworks.org/pages/blog/scapy-revfrag). Check other tools such as [Sniffjoke](https://github.com/vecna/sniffjoke)



## Reverse proxies
#### Introduction 
Before anything the evaluator needs to get a first idea of how the reverse proxy of the TOE actually works (this is almost 100% lifted from an [Acunetix blog post by Aleksei Tiurin](https://www.acunetix.com/blog/articles/a-fresh-look-on-reverse-proxy-related-attacks/))
* request processing
    * request parsing to obtain  a verb, a path, a HTTP version, host header and other headers and bod
        * VERB: Is it case sensitive for verbs?
        * PATH:
            * Absolute-URI
                * Is it supported?
                * Is any scheme accepted? (`scheme:[//authority]path[?query][#fragment]`)
                * Is @ accepted?
                * Does it have higher priority than Host header?
            * Does it allow
                * %2f as the first slash 
                * /../ higher than root
                * non encoded symbols in the path: %00 0x00 % # %2f (encoded slash), %0a (CR), others?
            * Does it skip fragments? after which char?
            * Does it normalize
                * /.. 
                * //
            * Does it treat // as a directory (/images/1.jpg/..//../2.jpg -> /images/2.jpg)
            * Does %0a cut the path? 
        * HTTP VERSION: Which versions are supported as input? which versions does the proxy use as output?
        * HOST HEADER: does it route by host or IP?
    * URL decoding
    * Path normalisation
        * test various patterns at various places in the path: /.., /../, //, /..;/ (path parameters), \..\
* applying rules: are they applied on processed paths or unprocessed paths, are they case sensitive? clarify which rules are applied:
    * rerouting
    * path/query rewriting
    * allow/deny access
    * modification/addition of headers
    * modification/addition of body
* forwarding to the backend: will it send the processed request or the original request? In the latter case, how does it reencode URLs? An example given on the original blog post show that nginx does not encode all the usual characters and can therefore be used as a springboard to perform an XSS on the backend. Another case shows how it handles differently the forwarding depending on the presence of a trailing slash in the rule.
* response processing
    * caching
    * modification/addition of headers
    * modification/addition of body

Part of the attacks will concern errors or specific ways to perform these tasks. The other attacks will rather be related to the difference of how requests are interpreted by the proxy wrt how they are interpreted by the backend. This is a very similar case to to the firewall problem exposed [in this method](#firewalls---ids---ids) (In some cases, the interpretation by a third party, the user browser, may also play a role).

### Request smuggling
The typical attack here is the [request smuggling](https://www.sans.org/blog/http-request-smuggling-abusing-reverse-proxies/). In this example, this will mostly be a question of clarifying how both parties interpret the size of the request payload (declaration via Content-Length vs Transfer-Encoding). 
 - The attacker pushes a second request in the content of the first one because the proxy inteprets the request as having la large size, but
 - this second request is separated from the first one by the backend, which interprets the request as having a small size. 
 - eventually the attacker hopes that this dangling request will be caught up by another (ideally authenticated) request.

The evaluator can take this example as a PoC, using the requests given as example

### Bypassing restrictions, misroute a request, SSRF...
Variations on this principle can lead to other types of attacks.

#### Trim Inconsistencies
The simplest example is the trim inconsistency described on [Rafa's blog](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies). 
* the proxy defines a deny list (e.g. on the path `/admin/`)
* inconsistency: when processing the path, 
    * the proxy does not trim a given non encoded character (e.g.\xa0), BUT
    * the endpoint *does* trim this character
In this case, the attacker can send a request to `/admin\xa0/`. It will not trip the deny rule, and will be forwarded as it is by the reverse proxy. But it will be interpreted as `/admin/` by the endpoint, thereby bypassing the restriction. 
If the proxy used is well known, the evaluator may try to get detailed information on how it interprets paths (a detailed [cheatsheet](https://github.com/GrrrDog/weird_proxies/tree/master) lists many articles from the state-of-the-art and the behaviours of many well-known proxies, such as nginx or apache. Additional data can be gathered from [HTTP.ninja](https://github.com/irsdl/httpninja), but not updated since 2019)

#### Errors in request parsing
The same [Rafa's blog](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) shows that using line splitting in paths can lead to part of the string being interpreted as a header in the request, thereby also possibly leading to the proxy incorrectly applying their rules.

Many more restriction bypass attacks can be built on a similar principle. Attacks will mostly consist in :
 - check first which path will be forwarded!
 - if the *proxy* ignores a part of the forwarded path, focus on putting forbidden parts in this dropped part, so that it passes the rules, and leverage the target normalisation to point on the right resource (/public#/../protected/) 
 - if the *target* ignores a part of the forwarded path, leverage the proxy normalization to make the complete URL pass the rules (/protected#/../public), see nginx+gunicorn in [this example](https://speakerdeck.com/greendog/2-and-a-bit-of-magic?slide=11)
 - if the path rewriting rules cut a prefix, put your target path after this prefix (e.g. /prefix/http://localhost/protected) 


#### Errors in path building
The same blog again gives an example where the path is built by concatenating the host name and relative path, without checking the trailing slash in the host name. More generally, this means that the TOE will trust a string [trusted host name][any string] to be a subpart of the trusted host name, which is not necassarily the case. In this case, an SSRF is possible by providing @a_malicious_domain.com as a relative path 

[TODO] To be defined following:
 - the rest of [Greendog](https://www.acunetix.com/blog/articles/a-fresh-look-on-reverse-proxy-related-attacks/)
 - https://threatpost.com/url-parsing-bugs-dos-rce-spoofing/177493/ 
 - other resources on https://github.com/GrrrDog/weird_proxies/tree/master?tab=readme-ov-file



## VPNs - secure channels
Regardless of potential privilege escalation, a protocol may provide security properties (integrity, confidentiality, anti-replay...). As a part of a general *Information flow bypass*, the evaluator should try to check whether the protocol itself can be bypassed
 - [TODO] secure channel
 - [TODO] kill switch / firewall part of the secure channel

## Diodes - TAPs
 - [TODO] attacks on directionality / protocol translation
 - [TODO] out of scope: HW attacks on optical diodes


# Tamper or craft TOE outputs - pivoting or output poisoning

The scenario consists in either

* crafting outputs to support another attack (e.g. erasing error messages from a log)
* crafting an input so that the TOE creates a malicious output (e.g. log poisoning). A weaker version consists in using the TOE to tunnel malicious content (e.g. port forwarding to another target).

## Misuse reverse proxies
This [article](https://www.acunetix.com/blog/articles/a-fresh-look-on-reverse-proxy-related-attacks/) and associated [slideware](https://speakerdeck.com/greendog/reverse-proxies-and-inconsistency?slide=14) shows two possible ways to misuse reverse proxies against users:
 - misuse the cache
 - misuse the header modification 

### Cache poisoning
[Rafa's blog](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies) gives an example of cache poisoning by leveraging peculiarities of the endpoint interpretation
* When multiple host headers are included in the request, only the first one will be taken, and any additional headers will be ignored.
* The following bytes are ignored if present in the header name: \x1f, \x1d, \x0c, \x1e, \x1c, \x0b;

````
GET / HTTP/1.1
[\x1d]Host: evilbucket.com
Host: example.bucket.com
Connection: close
````

In that case, the proxy does not read [\x1d]Host: evilbucket.com as a host, while the endpoint does. This leads to putting the content of evilbucket.com on the cache and providing to future users looking for example.bucket.com

## log tampering
 - [TODO] erase messages / inject content in the logs
## Tunnel/forward malicious content through the TOE
For firewalls and similar:
 - IPv6: check that the TOE rewrites all non-zero flow labels originating from a potentially compromised device, as it can be used as a covert channel (see [RFC 6437](https://datatracker.ietf.org/doc/html/rfc6437))
 - [TODO] see notably SSH forwarding etc
## Emit malicious content through the TOE 
this case is a bit different, since it supposes that the attacker can use the TOE itself to transform input data in malicious data for other systems connected to the TOE. It requires 
 - either that the attacker exploits TOE input transformation rules,  
 - or that the attacker elevates their privileges on the TOE to craft arbitrary malicious data. In real life scenarios,
 - a preauth SSRF can for example be used by an attacker to make a network scan from the TOE and discover its next targets
 - logs could be poisoned so as to include malicious content for the software that will read them
 - etc

[TODO]: add:
 - practical test steps for pentesting the capacity to recompose malicious data through gateways, diodes...
 - how to setup a test lab without real devices (EVE-NG, etc)

# Notes on DoS

As a general rule, this method does not provide guidelines to test DoS scenarios, since they are generally not relevant in a CC context. Only if the TOE claims resistance to DoS, the evaluator may try the following leads:
 - "antique" attacks on TCP (a syn flood with [hping3](https://www.kali.org/tools/hping3/) or [Naptha](https://packetstormsecurity.com/0101-exploits/naptha-1.1.tgz)). However, this should not be tested by default.
 - leverage the size of subnets in IPv6 to leverage specific DoS scenarios, see [RFC 6583](https://datatracker.ietf.org/doc/rfc6583/)
 - classical DoS fragmentation attacks (such as Teardrop/Nestea/Bonk/Jolt2/etc)
 - use ICMP type 3 or 4 (bandwidth exhaustion).



# TODO
[TODO] complete with:
 - [nsa23]:  National Security Agency | Cybersecurity Information Sheet IPv6 Security Guidance, 2023
 - [Ull14]:  Johanna Ullrich, Katharina Krombholz, Heidelinde Hobel, Adrian Dabrowski, Edgar Weippl  - IPv6 Security: Attacks and Countermeasures in a Nutshell (Usenix 2014) 
 - [WWW-layer2](https://www.whitewinterwolf.com/posts/2017/10/10/practical-network-layer-2-exploitation-introduction/#series-toc)
 - [Hacktricks-network](https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network)
