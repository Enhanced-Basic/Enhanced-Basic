# General approach
Whatever the starting point, a product evaluation is not a CTF! The evaluator has more information (and access) than the attacker. This is the reason why an evaluator spending only 2 weeks on a product is able to say that the product will resist 3 months of analysis by an atacker with the same skillset.

Consequently the evaluator **must** leverage any advantages they have over a blackbox situation,: documentation, root access on the TOE, etc. 

On the other hand, CC requires the developer to provide information. The standard does require a complete and meaningful documentation, but in a manner that is technology agnostic: this often results in a documentation that mindlessly tries to meet CC requirements contextualizing/tailoring the requirement for the specific TOE type. This ultimately leads to a documentation that will be useless for AVA_VAN purpose. 

This method refines the CC requirements for linux TOEs in order to ensure the evaluator gets meaningful information when starting AVA_VAN activities. 

## Available Documentation

In a CC evaluation, for each topic, the evaluator will first try to determine whether the ADV documentation is sufficiently clear. In a second step, the evaluator will check that the TOE conforms to this description. This second check should preferably be performed during the ADV review if the TOE is already available, but can be performed later.

NB: we will focus the AVA analysis on parts that have been patched/developed by the developer. 
Other programs can be skipped in the context of an AVA_VAN.3: we do not expect to be able to find vulnerabilities is known linux components in the constraint time of an evaluation.

| Topic | Expected content of ADV |
| :---- | :----   |
| TOE components |List kernel and distribution versions. Give a full list of installed programs and their versions. Classify in either<br> - Upstream: pure upstream components from the base OS repos<br> - Non-upstream: components added from other repos, or patched/developed by the TOE developer. |
| _Non-upstream_ : sources |List the developer of the component (proprietary, open source) and sources (install before delivery, address of the remote repository...)<br>Explain which protections measures are taken for the update (https access to mirrors, GPG verification)|
| _Non-upstream_ : files |List the files constituting the component: executables, libraries, config files... (folders, if too many files)|
| _Non-upstream_ : required privileges |Describe what privileges it requires for its execution, and why:<br> - execution as root or SUID rights<br> - sudo privileges<br> - capabilities<br>Comment any systemd unit used for the component|
| _Non-upstream_ : services, processes... |List the services, processes, scheduled/cron jobs that result from the execution of the component.|
| _Non-upstream_ : Sockets, D-Bus... | LIst the sockets / d-bus used by the component |
| File system and drives | Describe the filesystem of the TOE, and the associated permissions (incl. nosuid, nodev, noexec)<br>List all drives, their intended use and how credentials are used, if any |
| Users, groups | List the users and groups, with their respective privileges (esp. access to sudo/su)<br>What is the password Policy for users, and how (by which means) it is enforced?<br>which parts have access to PAM? |
| Hardening| Which hardening measures are used? (Yama ptrace scope, AppArmor, grsec, PaX, Execshield, SELinux, ASLR...)|
| General list of network dependencies|List the third-parties that are expected to be connected to the TOE through the network:<br> - does the product use a third-party SSO? PKI services such as OCSP?<br> - does the product rely on an external NTP, etc.?<br> - does the product rely on a back office for licensing, product updates? <br> - does the product rely on repositories to update 3rd party building blocks (distro, libraries...)?<br> - etc.|
| Supported protocols - Data link layer | Describe which standards are supported by the TOE at the link layer, with a focus on security protocols<br>Example: _The TOE supports 802.03/ethernet, and wifi/802.11 with WPA2/802.11i. (WEP is not supported)_|
| Supported protocols - Internet layer | Describe which standards are supported by the TOE at the internet layer, with a focus on security protocols.<br>Example: _The TOE supports IPv4 and IPv6_<br>Example2: _The TOE supports IPSec/ESP in tunnel mode on IPv6 only (no IPv4), with the following cipher suites: etc._|
| Supported protocols - network layer | Describe which standards are supported by the TOE at the network layer, with a focus on security protocols.<br>Example: _The TOE supports mainly TCP connections. UDP is used as underlying layer for several utilities: NTP and DHCP_|
| Supported protocols - applicative layer | List all the programs/services/TOE parts that uses the network and describe:<br> - whether the TOE is server or client <br> - which ports are used<br> - which applicative protocols are used, and according to which standard (if several are available)<br>If the TOE includes pure upstream components, the developer does not have to describe all the applicative protocols used by these components. However, the configuration of these services must be clearly described. For example, if the TOE includes a full non-patched Linux, the developer should still explain which network-aware services are loaded and why they are needed.<br>For TOE parts, prefer a description at process level. Comment the attribution of network-related capabilities if any|
|Firewalling|Describe which firewalling features are in place on the TOE (e.g. iptables, ufw...) and explain their default configuration|
As a rule of thumb, the evaluator should be able to answer the following questions: 
 - Identify where network data is stored on the TOE: e.g. which process holds network data in memory? which files/sockets hold traffic data?
 - Identify which services and associated resources control
	 -  how the network data flow is handled in practice (e.g. iptables, FW config files...).
	 -  how identification, authentication, authorization and access control of users is handled in practice


**Example**: if the TOE uses OpenSSL to create a TLS trusted channel the target of the attacker would be as follows:
 - cleartext traffic is likely to be accessible only in the memory of the process that uses the SSL_read or SSL_write, while only encrypted traffic appears in the socket used by OpenSSL. 
 - the config file to target would mainly be openssl.cnf, but also the potential config files of the applications that make use of openSSL.


## Additional information gathering 

Logged in as root on the TOE, run 
 - the [Low hanging fruits script](_0_System_AVA_testing\_resources\Low_hanging_fruits.sh): ````sudo ./Low_hanging_fruits.sh > Low_hanging_fruits.md````
 - the [Identification script](_0_System_AVA_testing\_resources\Identification.sh): ````sudo ./Identification.sh > Identification.md````




