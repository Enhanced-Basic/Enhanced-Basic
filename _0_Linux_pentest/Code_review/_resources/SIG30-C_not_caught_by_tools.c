#include <string.h>
#include <setjmp.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>

enum { MAXLINE = 1024 };

/*
Example:
In this noncompliant example, the C standard library functions fputs() and free() are called from the signal handler via the function log_message(). Neither function is asynchronous-safe.
*/
char *info = NULL;
 
void log_message(void) {
  fputs(info, stderr);
}
 
void handler(int signum) {
  log_message();
  free(info);
  info = NULL;
}


/*Example 2 (longjmp())
Invoking the longjmp() function from within a signal handler can lead to undefined behavior if it results in the invocation of any non-asynchronous-safe functions. Consequently, neither longjmp() nor the POSIX siglongjmp() functions should ever be called from within a signal handler.

This noncompliant code example is similar to a vulnerability in an old version of Sendmail [VU #834865]. The intent is to execute code in a main() loop, which also logs some data. Upon receiving a SIGINT, the program transfers out of the loop, logs the error, and terminates.

However, an attacker can exploit this noncompliant code example by generating a SIGINT just before the second if statement in log_message(). The result is that longjmp() transfers control back to main(), where log_message() is called again. However, the first if statement would not be executed this time (because buf is not set to NULL as a result of the interrupt), and the program would write to the invalid memory location referenced by buf0.
*/

 
static jmp_buf env;
 
void handler2(int signum) {
  longjmp(env, 1);
}
 
void log_message2(char *info1, char *info2) {
  static char *buf = NULL;
  static size_t bufsize;
  char buf0[MAXLINE];
 
  if (buf == NULL) {
    buf = buf0;
    bufsize = sizeof(buf0);
  }
 
  /*
   * Try to fit a message into buf, else reallocate
   * it on the heap and then log the message.
   */
 
  /* Program is vulnerable if SIGINT is raised here */
 
  if (buf == buf0) {
    buf = NULL;
  }
}


/*
Example 3(raise())
In this noncompliant code example, the int_handler() function is used to carry out tasks specific to SIGINT and then raises SIGTERM. However, there is a nested call to the raise() function, which is undefined behavior.
*/
  
void term_handler(int signum) {
  /* SIGTERM handler */
}
  
void int_handler(int signum) {
  /* SIGINT handler */
  if (raise(SIGTERM) != 0) {
    /* Handle error */
  }
}
  

int main(void) {
/*Example 1*/
  if (signal(SIGINT, handler) == SIG_ERR) {
    /* Handle error */
  }
  info = (char *)malloc(MAXLINE);
  if (info == NULL) {
    /* Handle Error */
  }
 
  while (1) {
    /* Main loop program code */
 
    log_message();
 
    /* More program code */
  }

  /*Example 2*/
  if (signal(SIGINT, handler2) == SIG_ERR) {
    /* Handle error */
  }
  char *info1;
  char *info2;
 
  /* info1 and info2 are set by user input here */
 
  if (setjmp(env) == 0) {
    while (1) {
      /* Main loop program code */
      log_message2(info1, info2);
      /* More program code */
    }
  } else {
    log_message2(info1, info2);
  }
 /*Example3*/
   if (signal(SIGTERM, term_handler) == SIG_ERR) {
    /* Handle error */
  }
  if (signal(SIGINT, int_handler) == SIG_ERR) {
    /* Handle error */
  }
  
  /* Program code */
  if (raise(SIGINT) != 0) {
    /* Handle error */
  }
  /* More code */

  return 0;
}

