#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>

/* 
    This C snippet exhibits errors caught by gcc. Just compile this test example with 

    └─$ gcc -Wuninitialized  -Wall -Wextra -Wformat -o test  EXP33-C_caught_by_gcc.c
    EXP33-C_caught_by_gcc.c: In function ‘report_error’:
    EXP33-C_caught_by_gcc.c:30:3: warning: ‘error_log’ is used uninitialized [-Wuninitialized]
    30 |   sprintf(buffer, "Error: %s, %s", error_log, msg);
        |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    EXP33-C_caught_by_gcc.c:27:15: note: ‘error_log’ was declared here
    27 |   const char *error_log;

*/

/* 
---- Rule EXP33-C. Do not read uninitialized memory ----
 */

/*  Example 1  (Uninitialized Local)
In this noncompliant code example, the programmer mistakenly fails to set the local variable error_log to the msg argument in the report_error() function [Mercy 2006]. Because error_log has not been initialized, an indeterminate value is read. The sprintf() call copies data from the arbitrary location pointed to by the indeterminate error_log variable until a null byte is reached, which can result in a buffer overflow.
*/

/* Get username and password from user, return -1 on error */
enum { BUFFERSIZE = 24 }; 
void report_error(const char *msg) {
  const char *error_log;
  char buffer[BUFFERSIZE];
 
  sprintf(buffer, "Error: %s, %s", error_log, msg);
  printf("%s\n", buffer);
}



/* main */
int main(int argc, char *argv[]) {
    int i;
    printf("%d\n",argc);
    for(i=0;i<argc-1;i++)
    {
        printf("%s", argv[i]);
    }    
    report_error("Error");
    
    return 0;    
}
