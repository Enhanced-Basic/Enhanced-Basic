#define __STDC_WANT_LIB_EXT1__ 1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <stddef.h>
#include <stdint.h>
/*
 This C code snippet exhibits errors that are not found by either gcc, splint or clang-tidy 

  ─$ splint ARR38-C_not_caught_by_tools.c -mustfreefresh -unrecog
  Splint 3.1.2 --- 21 Feb 2021

  ARR38-C_not_caught_by_tools.c: (in function func)
  ARR38-C_not_caught_by_tools.c:24:11: Passed storage w_buffer not completely
      defined (*w_buffer is undefined): wmemcpy (w_buffer, ...)
    Storage derivable from a parameter, return value or global is not defined.
  ARR38-C_not_caught_by_tools.c:24:3: Return value (type wchar_t *) ignored:
                                        wmemcpy(w_buffer...
    Result returned by function call is not used. If this is intended, can cast
    result to (void) to eliminate message. (Use -retvalother to inhibit warning)

  Finished checking --- 2 code warnings
                                               
  └─$ clang-tidy ARR38-C_not_caught_by_tools.c               
  5 warnings generated.
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:23:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(buffer, str, sizeof(str)); 
    ^~~~~~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:23:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(buffer, str, sizeof(str)); 
    ^~~~~~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:38:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(p, 0, n);
      ^~~~~~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:38:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(p, 0, n);
      ^~~~~~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:39:1: warning: Potential leak of memory pointed to by 'p' [clang-analyzer-unix.Malloc]
  }
  ^
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:33:21: note: Memory is allocated
    char *p = (char *)malloc(nchars);
                      ^~~~~~~~~~~~~~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:37:7: note: Assuming 'p' is not equal to NULL
    if (p != NULL)
        ^~~~~~~~~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:37:3: note: Taking true branch
    if (p != NULL)
    ^
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:39:1: note: Potential leak of memory pointed to by 'p'
  }
  ^
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:49:24: warning: Value stored to 'p' during its initialization is never read [clang-analyzer-deadcode.DeadStores]
      void *p = a;
                        ^   ~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:49:24: note: Value stored to 'p' during its initialization is never read
      void *p = a;
                        ^   ~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:89:22: warning: Value stored to 'nread' during its initialization is never read [clang-analyzer-deadcode.DeadStores]
    size_t nread = fread(wbuf, size, nitems, file);
                      ^~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  /home/kali/Downloads/test_code_review/ARR38-C_not_caught_by_tools.c:89:22: note: Value stored to 'nread' during its initialization is never read
    size_t nread = fread(wbuf, size, nitems, file);
                      ^~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      
*/

/*
Example 1  (Element Count)
In this noncompliant code example, the incorrect element count is used in a call to wmemcpy(). The sizeof operator returns the size expressed in bytes, but wmemcpy() uses an element count based on wchar_t *.
*/

static const char str[] = "Hello world";
static const wchar_t w_str[] = L"Hello world";
void func(void) {
  char buffer[32];
  wchar_t w_buffer[32];
  memcpy(buffer, str, sizeof(str)); /* Compliant */
  wmemcpy(w_buffer, w_str, sizeof(w_str)); /* Noncompliant */
}

/*
Example 2:
This noncompliant code example assigns a value greater than the number of bytes of available memory to n, which is then passed to memset():
*/

void f1(size_t nchars) {
  char *p = (char *)malloc(nchars);
  /* ... */
  const size_t n = nchars + 1;
  /* ... */
  if (p != NULL)
    memset(p, 0, n);
}

/*
Example 3:
In this noncompliant code example, the element count of the array a is ARR_SIZE elements. Because memset() expects a byte count, the size of the array is scaled incorrectly by sizeof(int) instead of sizeof(long), which can form an invalid pointer on architectures where sizeof(int) != sizeof(long).
*/
void f2(void) {
    const size_t ARR_SIZE = 4;
    long a[ARR_SIZE];
    /*@unused@*/ const size_t n = sizeof(int) * ARR_SIZE;
    /*@unused@*/ void *p = a;
    
    /* whether you use memset or memset_s, you still aren't filling you buffer correctly if sizeof(int)!=sizeof(long)*/
    /*memset(p, 0, n);*/
    #ifdef __STDC_LIB_EXT1__
    memset_s(p, n, 0, n);
    #endif

}


/*
Example 4 (One Pointer + Two Integers)
This noncompliant code example allocates a variable number of objects of type struct obj. The function checks that num_objs is small enough to prevent wrapping, in compliance with INT30-C. Ensure that unsigned integer operations do not wrap. The size of struct obj is assumed to be 16 bytes to account for padding to achieve the assumed alignment of long long. However, the padding typically depends on the target architecture, so this object size may be incorrect, resulting in an incorrect element count
*/
struct obj {
  char c;
  long long i;
};
  
void f5(FILE *f, struct obj *objs, size_t num_objs) {
  const size_t obj_size = 16;
  if (num_objs > (SIZE_MAX / obj_size) ||
      num_objs != fwrite(objs, obj_size, num_objs, f)) {
    /* Handle error */
  }
}

/* 
Example 5 (One Pointer + Two Integers)
In this noncompliant code example, the function f() calls fread() to read nitems of type wchar_t, each size bytes in size, into an array of BUFFER_SIZE elements, wbuf. However, the expression used to compute the value of nitems fails to account for the fact that, unlike the size of char, the size of wchar_t may be greater than 1. Consequently, fread() could attempt to form pointers past the end of wbuf and use them to assign values to nonexistent elements of the array. Such an attempt is undefined behavior. (See undefined behavior 109.)  A likely consequence of this undefined behavior is a buffer overflow. For a discussion of this programming error in the Common Weakness Enumeration database, see CWE-121, "Stack-based Buffer Overflow," and CWE-805, "Buffer Access with Incorrect Length Value."
*/
 
void f6(FILE *file) {
  enum { BUFFER_SIZE = 1024 };
  wchar_t wbuf[BUFFER_SIZE];
 
  const size_t size = sizeof(*wbuf);
  const size_t nitems = sizeof(wbuf);
 
  /*@unused@*/size_t nread = fread(wbuf, size, nitems, file);
  /* ... */
}


/* main */
int main(int argc, char *argv[]) {
    int i;
    printf("%d\n",argc);
    for(i=0;i<argc-1;i++)
    {
        printf("%s",argv[i]);
    }    
    return 0;    
}
