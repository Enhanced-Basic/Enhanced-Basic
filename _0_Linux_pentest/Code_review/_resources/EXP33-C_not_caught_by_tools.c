#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <stdlib.h>
#include <stdio.h>

/* 
    This C snippet exhibits errors caught by neither gcc, nor clang-tidy, nor splint

    compile this test example with 
    gcc -Wuninitialized  -Wall -Wextra  -o test test_not_caught_by_gcc.c 

    clang-tidy EXP33-C_not_caught_by_tools.c does not catch the error
    splint EXP33-C_not_caught_by_tools.c -temptrans ends in a parsing error
*/

/* 
---- Rule EXP33-C. Do not read uninitialized memory ----
 */


/* Example 1 (realloc())
The realloc() function changes the size of a dynamically allocated memory object. The initial size bytes of the returned memory object are unchanged, but any newly added space is uninitialized, and its value is indeterminate. As in the case of malloc(), accessing memory beyond the size of the original object is undefined behavior 181.
It is the programmer's responsibility to ensure that any memory allocated with malloc() and realloc() is properly initialized before it is used.
In this noncompliant code example, an array is allocated with malloc() and properly initialized. At a later point, the array is grown to a larger size but not initialized beyond what the original array contained. Subsequently accessing the uninitialized bytes in the new array is undefined behavior.*/

enum { OLD_SIZE = 10, NEW_SIZE = 20 }; 
/*@null@*/ int *resize_array(int *array, size_t count) {
    if (0 == count)
    {
      return 0;
    }
    int *ret = (int *)realloc(array, count * sizeof(int));
    if (!ret) {
        /*free(array);*/
        return 0;
    }
    return ret;
}  
void uninitialized_realloc(void) {
    int *array = (int *)malloc(OLD_SIZE * sizeof(int));
    if (0 == array) 
    {
      /* Handle error */
    } 
    for (size_t i = 0; i < OLD_SIZE; ++i)
    {
      array[i] = i;
    }
    array = resize_array(array, NEW_SIZE);
    if (0 == array) {} /* Handle error */  
    /* And now, UB after 10 */
    for (size_t i = 0; i < NEW_SIZE; ++i) printf("%d ", array[i]);
}


/* main */
int main(int argc, char *argv[]) {
    int i;
    printf("%d\n",argc);
    for(i=0;i<argc-1;i++)
    {
        printf("%s", argv[i]);
    }    

    return 0;    
}
