#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>
#include <stdlib.h>
#include <png.h> /* From libpng */
  
/* 
    This C snippet exhibits errors not caught by neither gcc nor splint (NB: splint execution will require to define a lot of types in .splintrc) nor clang-tidy:
    
    └─$ splint EXP34-C_not_caught_by_tools.c +matchanyintegral -mustfreefresh
    Splint 3.1.2 --- 21 Feb 2021

    Finished checking --- no warnings    

    └─$ clang-tidy EXP34-C_not_caught_by_tools.c 
    Error while trying to load a compilation database:
    Could not auto-detect compilation database for file "EXP34-C_not_caught_by_tools.c"
    No compilation database found in /home/kali/Downloads/test_code_review or any parent directory
    fixed-compilation-database: Error while opening fixed database: No such file or directory
    json-compilation-database: Error while opening JSON database: No such file or directory
    Running without flags.
    1 warning generated.
    /home/kali/Downloads/test_code_review/EXP34-C_not_caught_by_tools.c:31:5: warning: Value stored to 'chunkdata' is never read [clang-analyzer-deadcode.DeadStores]
        chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
        ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    /home/kali/Downloads/test_code_review/EXP34-C_not_caught_by_tools.c:31:5: note: Value stored to 'chunkdata' is never read
        chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
*/

/* 
---- EXP34-C. Do not dereference null pointers ----
 */

/*  Example 1  
This noncompliant code example is derived from a real-world example taken from a vulnerable version of the libpng library as deployed on a popular ARM-based cell phone [Jack 2007](https://wiki.sei.cmu.edu/confluence/display/c/AA.+Bibliography#AA.Bibliography-Jack07). The  libpng library allows applications to read, create, and manipulate PNG (Portable Network Graphics) raster image files. The libpng library implements its own wrapper to malloc() that returns a null pointer on error or on being passed a 0-byte-length argument.

This code also violates ERR33-C. Detect and handle standard library errors.

If length has the value −1, the addition yields 0, and png_malloc() subsequently returns a null pointer, which is assigned to chunkdata. The chunkdata pointer is later used as a destination argument in a call to memcpy(), resulting in user-defined data overwriting memory starting at address 0. In the case of the ARM and XScale architectures, the 0x0 address is mapped in memory and serves as the exception vector table; consequently, dereferencing 0x0 did not cause an abnormal program termination.
*/

void func(png_structp png_ptr, int length, const void *user_data) {
    png_charp chunkdata;
    chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
    /* ... */
    #ifdef __STDC_LIB_EXT1__
    memcpy_s(chunkdata, sizeof(png_charp), user_data, length);
    #endif
    /* ... */
}
/*  Example 2
In this noncompliant code example, input_str is copied into dynamically allocated memory referenced by c_str. If malloc() fails, it returns a null pointer that is assigned to c_str. When c_str is dereferenced in memcpy(), the program exhibits undefined behavior.  Additionally, if input_str is a null pointer, the call to strlen() dereferences a null pointer, also resulting in undefined behavior. This code also violates ERR33-C. Detect and handle standard library errors.
*/

void f(const char *input_str) {
    size_t size = strlen(input_str) + 1;
    char *c_str = (char *)malloc(size);

    #ifdef __STDC_LIB_EXT1__
    memcpy_s(c_str, sizeof(c_str), input_str, size);
    #endif
    /* ... */
    free(c_str);
    c_str = NULL;
    /* ... */
}

/* main */
int main(int argc, char *argv[]) {
    int i;
    printf("%d\n",argc);
    for(i=0;i<argc-1;i++)
    {
        printf("%s", argv[i]);
    }    
    return 0;    
}
