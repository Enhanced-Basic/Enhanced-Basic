#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

/*
 This C code snippet exhibits errors that are not found by either splint or clang-tidy 

    └─$ clang-tidy -checks=-*,clang-analyzer-*,-clang-analyzer-cplusplus* STR31C-C_caught_by_tools.c --
    1 warning generated.
    /home/kali/Downloads/test_code_review/STR31C-C_not_caught_by_tools.c:52:12: warning: Call to function 'fscanf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    if (1 != fscanf(stdin, "%s", buf)) {
            ^~~~~~
    /home/kali/Downloads/test_code_review/STR31C-C_not_caught_by_tools.c:52:12: note: Call to function 'fscanf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fscanf_s' in case of C11
    if (1 != fscanf(stdin, "%s", buf)) {
            ^~~~~~

*/


/*
Example 1 (fscanf())
In this noncompliant example, the call to fscanf() can result in a write outside the character array buf:
*/
enum { BUF_LENGTH = 1024 };
  
void get_data(void) {
  char buf[BUF_LENGTH];
  if (1 != fscanf(stdin, "%s", buf)) {
    /* Handle error */
  }
 
  /* Rest of function */
}

/*
Example (getenv())
According to the C Standard, 7.22.4.6 [ISO/IEC 9899:2011]

The getenv function searches an environment list, provided by the host environment, for a string that matches the string pointed to by name. The set of environment names and the method for altering the environment list are implementation defined.

Environment variables can be arbitrarily large, and copying them into fixed-length arrays without first determining the size and allocating adequate storage can result in a buffer overflow.

This is, yet again, an example of the problem with using strcpy
*/

void func(void) {
  char buff[256];
  char *editor = getenv("EDITOR");
  if (editor == NULL) {
    /* EDITOR environment variable not set */
  } else {
    strcpy(buff, editor);
  }
}

/* Example (argv)
In a hosted environment, arguments read from the command line are stored in process memory. The function main(), called at program startup, is typically declared as follows when the program accepts command-line arguments:

Command-line arguments are passed to main() as pointers to strings in the array members argv[0] through argv[argc - 1]. If the value of argc is greater than 0, the string pointed to by argv[0] is, by convention, the program name. If the value of argc is greater than 1, the strings referenced by argv[1] through argv[argc - 1] are the program arguments.

Vulnerabilities can occur when inadequate space is allocated to copy a command-line argument or other program input. In this noncompliant code example, an attacker can manipulate the contents of argv[0] to cause a buffer overflow:
*/

/*
Example (sprintf())
In this noncompliant code example, name refers to an external string; it could have originated from user input, the file system, or the network. The program constructs a file name from the string in preparation for opening the file.
Yet another dangerous function (sprintf)
*/
#include <stdio.h>
  
void sprintfpb(const char *name) {
  char filename[128];
  sprintf(filename, "%s.txt", name);
}


/* main */
int main(int argc, char *argv[]) {
  /* Ensure argv[0] is not null */
  const char *const name = (argc && argv[0]) ? argv[0] : "";
  char prog_name[128];
  strcpy(prog_name, name);
  return 0;    
}
