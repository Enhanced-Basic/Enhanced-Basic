#include <stddef.h>
#include <stdio.h>

/*
 This C code snippet exhibits errors caught by gcc 

    └─$ gcc  -Wall -Wextra -std=c99 -o test STR31C-C_not_caught_by_tools.c
    STR31C-C_not_caught_by_tools.c: In function ‘func’:
    STR31C-C_not_caught_by_tools.c:44:3: warning: ‘gets’ is deprecated [-Wdeprecated-declarations]
    44 |   if (gets(buf) == NULL) {
        |   ^~
    In file included from STR31C-C_not_caught_by_tools.c:2:
    /usr/include/stdio.h:663:14: note: declared here
    663 | extern char *gets (char *__s) __wur __attribute_deprecated__;
        |              ^~~~
    /usr/bin/ld: /tmp/ccZROjFO.o: in function `func':
    STR31C-C_not_caught_by_tools.c:(.text+0x7d): warning: the `gets' function is dangerous and should not be used.

    a build by default (gcc  -Wall -Wextra  -o test STR31C-C_not_caught_by_tools.c) will not accept gets at all (removed from the standard since C11)
*/

/*
Example 1  (gets())
The gets() function, which was deprecated in the C99 Technical Corrigendum 3 and removed from C11, is inherently unsafe and should never be used because it provides no way to control how much data is read into a buffer from stdin. This noncompliant code example assumes that gets() will not read more than BUFFER_SIZE - 1 characters from stdin. This is an invalid assumption, and the resulting operation can result in a buffer overflow.

The gets() function reads characters from the stdin into a destination array until end-of-file is encountered or a newline character is read. Any newline character is discarded, and a null character is written immediately after the last character read into the array.

*/


#define BUFFER_SIZE 1024
 
void func(void) {
  char buf[BUFFER_SIZE];
  if (gets(buf) == NULL) {
    /* Handle error */
  }
}



/* main */
int main(int argc, char *argv[]) {
    int i;
    printf("%d\n",argc);
    for(i=0;i<argc-1;i++)
    {
        printf("%s",argv[i]);
    }    
    return 0;    
}
