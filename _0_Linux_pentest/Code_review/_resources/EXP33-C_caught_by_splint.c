#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <stdlib.h>
#include <stdio.h>

/* 
    This C snippet exhibits errors not caught be gcc but caught by splint 

  ┌──(kali㉿kali)-[~/Downloads/test_code_review]
  └─$ splint EXP33-C_caught_by_splint.c +boolint -bufferoverflowhigh -exportlocal 
  Splint 3.1.2 --- 21 Feb 2021

  EXP33-C_caught_by_splint.c: (in function is_negative)
  EXP33-C_caught_by_splint.c:35:20: Passed storage &sign not completely defined:
                                      set_flag (..., &sign)
    Storage derivable from a parameter, return value or global is not defined.
  EXP33-C_caught_by_splint.c: (in function uninitialized_mbstate_t)
  EXP33-C_caught_by_splint.c:47:36: Passed storage &state not completely defined:
                                      mbrlen (..., &state)


*/

/* 
---- Rule EXP33-C. Do not read uninitialized memory ----
 */

/*  Example 1 (Return-by-Reference)
In this noncompliant code example, the set_flag() function is intended to set the parameter, sign_flag, to the sign of number. However, the programmer neglected to account for the case where number is equal to 0. Because the local variable sign is uninitialized when calling set_flag() and is never written to by set_flag(), the comparison operation exhibits undefined behavior when reading sign.
Some compilers assume that when the address of an uninitialized variable is passed to a function, the variable is initialized within that function. Because compilers frequently fail to diagnose any resulting failure to initialize the variable, the programmer must apply additional scrutiny to ensure the correctness of the code.
*/
void set_flag(int number, int *sign_flag) {
  if (NULL == sign_flag) {
    return;
  }
 
  if (number > 0) {
    *sign_flag = 1;
  } else if (number < 0) {
    *sign_flag = -1;
  }
  /* if zero, we have a problem... */
} 
int is_negative(int number) {
  /* should be detected as uninitialized*/
  int sign;
  set_flag(number, &sign);
  return sign < 0;
}
/* 
Example 1 bis (mbstate_t)
In this noncompliant code example, the function mbrlen() is passed the address of an automatic mbstate_t object that has not been properly initialized. This is undefined behavior 200 because mbrlen() dereferences and reads its third argument.
Same issue in the sense that it is again a problem of value passed by address.
*/
void uninitialized_mbstate_t(const char *mbs) {
    size_t len;
    mbstate_t state;
    /* mbrlen will try to dereference &state -> undefined behaviour */
    len = mbrlen(mbs, strlen(mbs), &state);
    printf("len=%ld", len);
}

/* main */
int main(int argc, char *argv[]) {
    int i;
    printf("%d\n",argc);
    for(i=0;i<argc-1;i++)
    {
        printf("%s", argv[i]);
    }    
    
    if (is_negative(0))
        printf("0 is negative");

    return 0;    
}
